<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SpacesAI</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <header class="topbar">
    <h4>SpacesAI ‚Ä¢ Personal Knowledge Spaces with RAG</h4>
    <div class="spacer"></div>
    <div id="userControls" class="user-controls" hidden>
      <span id="userEmail" class="user-email"></span>
      <button id="logoutBtn" class="ghost" title="Logout">Logout</button>
    </div>
    <button id="themeBtn" class="ghost" title="Toggle dark mode">üåì</button>
  </header>

  <main class="container">
    <!-- Hero and Auth -->
    <section class="card card--wide hero">
      <div class="logo" aria-label="SPACES" style="text-align:center">
        <span class="g g-blue">S</span>
        <span class="g g-red">P</span>
        <span class="g g-yellow">A</span>
        <span class="g g-blue">C</span>
        <span class="g g-green">E</span>
        <span class="g g-red">S</span>
      </div>

      <div id="authPanel" class="auth" hidden>
        <div class="row cols">
          <div class="auth-card" id="loginCard">
            <h3>Sign in</h3>
            <label class="block">Email</label>
            <input id="loginEmail" type="email" placeholder="you@example.com" />
            <label class="block">Password</label>
            <input id="loginPassword" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
            <button id="loginBtn" class="primary">Login</button>
            <p class="small">New here? <a href="#" id="showRegisterLink">Create account</a></p>
          </div>
          <div class="auth-card" id="registerCard" hidden>
            <h3>Create account</h3>
            <label class="block">Email</label>
            <input id="regEmail" type="email" placeholder="you@example.com" />
            <label class="block">Password</label>
            <input id="regPassword" type="password" placeholder="At least 8 characters" />
            <button id="registerBtn">Register</button>
            <p class="small"><a href="#" id="cancelRegisterLink">Back to sign in</a></p>
          </div>
        </div>
      </div>

      <div id="appPanel" class="app-panel" hidden>


        <div class="searchbar">
          <input id="query" class="search-input" type="text" placeholder="Search..." autocomplete="off" />
          <button id="drBtn" class="dr-icon" title="Deep Research">üî¨</button>
        </div>
        <div class="search-actions-row">
          <button id="searchBtn" class="primary">Search</button>
          <button id="settingsBtn" class="ghost" title="Settings" aria-expanded="false">‚öôÔ∏è</button>
        </div>

        <div id="settingsPanel" class="settings" hidden>
          <div class="row wrap">
            <div class="row no-grow">
              <label for="mode">Mode</label>
              <select id="mode">
                <option value="hybrid">Hybrid</option>
                <option value="semantic">Semantic</option>
                <option value="fulltext">Full-text</option>
                <option value="rag" selected>RAG</option>
              </select>
            </div>
            <div class="row no-grow">
              <label for="provider" class="leftpad">LLM Provider</label>
              <select id="provider">
                <option value="">Default</option>
                <option value="oci">OCI</option>
                <option value="openai">OpenAI</option>
                <option value="bedrock">Bedrock</option>
                <option value="ollama">Ollama</option>
              </select>
            </div>
            <div class="row no-grow">
              <label for="topk" class="leftpad">Top K</label>
              <input id="topk" type="number" value="25" min="1" max="50" />
            </div>
            <div class="row no-grow">
              <label for="autoSearch" class="leftpad">Auto search</label>
              <input id="autoSearch" type="checkbox" />
              <label for="debounceMs" class="leftpad">Debounce (ms)</label>
              <input id="debounceMs" type="number" value="400" min="100" max="2000" />
            </div>
          </div>
          <div class="row wrap">
            <div class="row no-grow">
              <strong>Search backend:</strong>&nbsp;<span id="cfgBackend">-</span>
            </div>
            <div class="row no-grow">
              <label for="cfgTopK" class="leftpad">Default Top K</label>
              <input id="cfgTopK" type="number" min="1" max="1000" placeholder="25" />
            </div>
            <div class="row no-grow" id="cfgPgvectorRow" hidden>
              <label for="cfgProbes" class="leftpad">pgvector probes</label>
              <input id="cfgProbes" type="number" min="1" max="10000" placeholder="env default" />
            </div>
            <div class="row no-grow" id="cfgNumCandRow" hidden>
              <label for="cfgNumCand" class="leftpad">OS num_candidates</label>
              <input id="cfgNumCand" type="number" min="1" max="1000000" placeholder="heuristic default" />
            </div>
            <div class="row no-grow">
              <button id="loadCfgBtn" class="ghost">Refresh config</button>
              <button id="saveCfgBtn" class="ghost">Save</button>
            </div>
          </div>
          <div class="row wrap">
            <label for="spacesSelect">Space</label>
            <select id="spacesSelect"></select>
            <button id="setDefaultSpaceBtn" class="ghost">Set default</button>
            <span class="leftpad"></span>
            <input id="newSpaceName" placeholder="Create new space‚Ä¶" />
            <button id="createSpaceBtn">Create</button>
          </div>
        </div>



        <div class="row middle">
          <div class="loader" id="searchLoading" hidden>
            <div class="spinner"></div>
            <span>Searching‚Ä¶</span>
          </div>
        </div>

        <div class="row" id="answerRow" hidden>
          <label>Answer / Context <span id="llmBadge" class="badge" style="display:none"></span></label>
          <pre id="answer" class="panel"></pre>
          <label id="refsLabel" style="display:none">References</label>
          <div id="refs" class="results" style="margin-top:8px; display:none"></div>
        </div>
        <div class="row" id="resultsRow" hidden>
          <label>Results</label>
          <div id="results" class="results"></div>
        </div>
      </div>
    </section>

    <!-- Knowledge Base -->
    <section id="kbSection" class="card card--wide" hidden>
      <button class="collapsible-toggle" id="kbToggle" aria-expanded="false"><span class="caret">‚ñ∏</span> Your Knowledge Base</button>
      <div id="kbContent" hidden>
        <div class="row wrap">
          <button id="kbRefreshBtn" class="primary">Refresh</button>
          <button id="kbSortBtn" class="ghost" title="Toggle sort order" style="margin-left:8px">Latest first</button>
          <span class="leftpad"></span>
          <button id="kbDeleteSelectedBtn" class="ghost" title="Delete selected">Delete selected</button>
        </div>
        <div class="row">
          <label><input type="checkbox" id="kbSelectAll" /> Select all</label>
        </div>
        <div class="row">
          <div id="kbList" class="results"></div>
        </div>
      </div>
    </section>
    </section>

    <!-- Upload -->
    <section id="uploadSection" class="card card--wide" hidden>
      <button class="collapsible-toggle" id="uploadToggle" aria-expanded="false"><span class="caret">‚ñ∏</span> Upload to your Space</button>
      <div id="uploadContent" hidden>
        <div class="row wrap" style="width:100%; justify-content: space-between; align-items: center;">
          <div>
            <button id="uploadBtn" class="primary">Upload</button>
            <div class="loader" id="uploadLoading" hidden style="display:inline-flex; margin-left:8px;">
              <div class="spinner small"></div>
              <span>Processing‚Ä¶</span>
            </div>
          </div>
          <button id="clearUploadBtn" class="ghost" title="Clear uploads"><span class="refresh-icon">‚Üª</span></button>
        </div>
        <div class="row">
          <div id="dropzone" class="dropzone">
            <div class="dz-inner">
              <div class="dz-header">Drag & drop files</div>
              <div class="dz-desc">Documents: PDF, DOCX, PPTX, XLSX, TXT, HTML, CSV, MD, JSON ‚Ä¢ Images: PNG, JPG, JPEG, TIFF, BMP, GIF</div>
              <div class="dz-hint" id="dzHint">Maximum 50MB per file ‚Ä¢ Maximum 100 files per batch</div>
              <div class="dz-status" id="dzStatus">Drop files here or use the file chooser below</div>
            </div>
          </div>
        </div>
        <div class="row">
          <input id="files" type="file" multiple accept=".pdf,.txt,.csv,.md,.json,.html,.htm,.docx,.pptx,.xlsx,.png,.jpg,.jpeg,.tif,.tiff,.bmp,.gif" />
        </div>
        <div class="row" id="uploadListRow" hidden>
          <div id="uploadList" class="progress-list"></div>
        </div>
        <div class="row" id="uploadStatusRow" hidden>
          <pre id="uploadStatus" class="panel"></pre>
        </div>
      </div>
    </section>
  </main>

  <div id="toast" class="toast" hidden></div>

  <div id="drBackdrop" class="dr-backdrop" hidden></div>
  <div id="drModal" class="dr-modal" hidden aria-modal="true" role="dialog">
    <div class="dr-header">
      <div style="display:flex; align-items:center; gap:10px" class="dr-title"><strong>Deep Research</strong><span class="microscope-icon">üî¨</span></div>
      <div style="display:flex; gap:6px; align-items:center">
        <button id="drReset" class="ghost" title="Reset conversation">‚Ü∫</button>
        <button id="drClose" class="ghost" title="Close">‚úï</button>
      </div>
    </div>
    <div id="drChat" class="dr-chat"></div>
    <div class="dr-input">
      <input id="drMessage" type="text" placeholder="Ask a deep question‚Ä¶" />
      <button id="drSend" class="primary">Send</button>
    </div>
  </div>

  <script>
    // Theme toggle
    (function(){
      const btn = document.getElementById('themeBtn');
      const curr = localStorage.getItem('theme');
      if (curr === 'dark') document.body.classList.add('dark');
      btn.addEventListener('click', () => {
        document.body.classList.toggle('dark');
        localStorage.setItem('theme', document.body.classList.contains('dark') ? 'dark' : 'light');
      });
    })();

    // Helpers
    function showToast(msg) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.hidden = false;
      setTimeout(() => { t.hidden = true; t.textContent = ''; }, 3000);
    }
    function escapeHtml(s) {
      return (s || '')
        .replace(/&/g, '&')
        .replace(/</g, '<')
        .replace(/>/g, '>')
        .replace(/\"/g, '"')
        .replace(/'/g, '&#039;');
    }
    function highlight(text, query) {
      if (!query) return escapeHtml(text);
      try {
        const esc = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = new RegExp(esc, 'ig');
        return escapeHtml(text).replace(re, m => `<mark>${escapeHtml(m)}</mark>`);
      } catch {
        return escapeHtml(text);
      }
    }
    function renderLLMText(s) {
      // Minimal markdown-ish renderer: code fences, lists, paragraphs
      const text = s || '';
      // Split code blocks
      const parts = text.split(/```/g);
      let html = '';
      for (let i = 0; i < parts.length; i++) {
        if (i % 2 === 1) {
          // code block
          html += `<pre class="code"><code>${escapeHtml(parts[i])}</code></pre>`;
        } else {
          // normal text -> handle lists and paragraphs
          const block = parts[i];
          const lines = block.split(/\r?\n/);
          let inUl = false, inOl = false;
          const out = [];
          const flushList = () => {
            if (inUl) { out.push('</ul>'); inUl = false; }
            if (inOl) { out.push('</ol>'); inOl = false; }
          };
          for (const raw of lines) {
            const ln = raw.trimEnd();
            if (/^\s*[-*]\s+/.test(ln)) {
              if (!inUl) { flushList(); out.push('<ul>'); inUl = true; }
              out.push(`<li>${escapeHtml(ln.replace(/^\s*[-*]\s+/, ''))}</li>`);
            } else if (/^\s*\d+\.\s+/.test(ln)) {
              if (!inOl) { flushList(); out.push('<ol>'); inOl = true; }
              out.push(`<li>${escapeHtml(ln.replace(/^\s*\d+\.\s+/, ''))}</li>`);
            } else if (ln.trim() === '') {
              flushList();
              out.push('<p></p>');
            } else {
              flushList();
              out.push(`<p>${escapeHtml(ln)}</p>`);
            }
          }
          flushList();
          html += out.join('');
        }
      }
      // Compact empty paragraphs
      html = html.replace(/(<p><\/p>\s*)+/g, '<p></p>');
      return html;
    }
    async function api(path, opts={}) {
      const res = await fetch(path, {
        method: opts.method || 'GET',
        headers: opts.body instanceof FormData ? undefined : { 'Content-Type': 'application/json' },
        body: opts.body ? (opts.body instanceof FormData ? opts.body : JSON.stringify(opts.body)) : undefined,
        signal: opts.signal,
      });
      if (!res.ok) throw new Error(await res.text());
      const ct = res.headers.get('content-type') || '';
      return ct.includes('application/json') ? await res.json() : await res.text();
    }

    // App state
    let state = {
      user: null,
      spaces: [],
      spaceId: null,
    };

    function setLoggedInUI() {
      const auth = document.getElementById('authPanel');
      const app = document.getElementById('appPanel');
      const up = document.getElementById('uploadSection');
      const kb = document.getElementById('kbSection');
      const uc = document.getElementById('userControls');
      const emailEl = document.getElementById('userEmail');
      if (state.user) {
        auth.hidden = true;
        app.hidden = false;
        up.hidden = false;
        if (kb) { kb.hidden = false; }
        uc.hidden = false;
        emailEl.textContent = state.user.email;
      } else {
        auth.hidden = false;
        app.hidden = true;
        up.hidden = true;
        if (kb) { kb.hidden = true; }
        uc.hidden = true;
        emailEl.textContent = '';
      }
    }

    function populateSpaces() {
      const sel = document.getElementById('spacesSelect');
      sel.innerHTML = '';
      for (const s of state.spaces) {
        const opt = document.createElement('option');
        opt.value = String(s.id);
        opt.textContent = s.name + (s.is_default ? ' (default)' : '');
        sel.appendChild(opt);
      }
      if (state.spaceId) sel.value = String(state.spaceId);
    }

    async function initUser() {
      try {
        const me = await api('/api/me');
        if (me && me.user) {
          state.user = me.user;
          state.spaces = me.spaces || [];
          const def = (state.spaces.find(s => s.is_default) || {}).id;
          state.spaceId = def || (state.spaces[0] ? state.spaces[0].id : null);
          populateSpaces();
        } else {
          state.user = null;
          state.spaces = [];
          state.spaceId = null;
        }
      } catch (e) {
        state.user = null;
        state.spaces = [];
        state.spaceId = null;
      }
      setLoggedInUI();
    }

    // Auth handlers
    document.getElementById('loginBtn').addEventListener('click', async () => {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      try {
        const resp = await api('/api/login', { method: 'POST', body: { email, password } });
        state.user = resp.user; state.spaces = resp.spaces || [];
        const def = (state.spaces.find(s => s.is_default) || {}).id;
        state.spaceId = def || (state.spaces[0] ? state.spaces[0].id : null);
        populateSpaces(); setLoggedInUI(); await loadKB(); showToast('Logged in');
      } catch (e) {
        let msg = 'Login failed';
        try { const js = JSON.parse(e.message || '{}'); if (js && js.error) msg = js.error; } catch {}
        showToast(msg);
      }
    });
    document.getElementById('registerBtn').addEventListener('click', async () => {
      const email = document.getElementById('regEmail').value.trim();
      const password = document.getElementById('regPassword').value;
      try {
        const resp = await api('/api/register', { method: 'POST', body: { email, password } });
        // For SaaS-like UX: redirect users back to sign in (do not auto-login)
        try { await api('/api/logout', { method: 'POST' }); } catch {}
        state = { user: null, spaces: [], spaceId: null };
        // Prefill login email for convenience
        const le = document.getElementById('loginEmail'); if (le) le.value = email;
        // Toggle back to login view
        const loginCard = document.querySelector('#authPanel #loginCard');
        const regCard = document.getElementById('registerCard');
        if (loginCard) loginCard.hidden = false;
        if (regCard) regCard.hidden = true;
        setLoggedInUI();
        showToast('Account created. Please sign in.');
      } catch (e) {
        let msg = 'Registration failed';
        try { const js = JSON.parse(e.message || '{}'); if (js && js.error) msg = js.error; } catch {}
        showToast(msg);
      }
    });
    document.getElementById('logoutBtn').addEventListener('click', async () => {
      try { await api('/api/logout', { method: 'POST' }); } catch {}
      state = { user: null, spaces: [], spaceId: null };
      setLoggedInUI();
      // Clear stored Deep Research conversations on logout
      try { Object.keys(localStorage).forEach(k => { if (k.startsWith('dr:space:')) localStorage.removeItem(k); }); } catch {}
      showToast('Logged out');
    });

    // Auth UI toggles
    (function(){
      const loginCard = document.querySelector('#authPanel .auth-card:nth-child(1)');
      if (loginCard) loginCard.id = 'loginCard';
      const regCard = document.getElementById('registerCard');
      const showReg = document.getElementById('showRegisterLink');
      const cancelReg = document.getElementById('cancelRegisterLink');
      if (showReg) showReg.addEventListener('click', (e) => { e.preventDefault(); if (regCard) regCard.hidden = false; if (loginCard) loginCard.hidden = true; });
      if (cancelReg) cancelReg.addEventListener('click', (e) => { e.preventDefault(); if (regCard) regCard.hidden = true; if (loginCard) loginCard.hidden = false; });
    })();

    document.getElementById('createSpaceBtn').addEventListener('click', async () => {
      const name = document.getElementById('newSpaceName').value.trim();
      if (!name) return;
      try {
        const resp = await api('/api/spaces', { method: 'POST', body: { name } });
        await initUser();
        document.getElementById('newSpaceName').value = '';
        showToast('Space created');
      } catch (e) { showToast('Failed to create space'); }
    });
    document.getElementById('setDefaultSpaceBtn').addEventListener('click', async () => {
      const sel = document.getElementById('spacesSelect');
      const sid = parseInt(sel.value || '0', 10);
      if (!sid) return;
      try {
        await api('/api/spaces/default', { method: 'POST', body: { space_id: sid } });
        await initUser();
        showToast('Default space updated');
      } catch (e) { showToast('Failed to set default'); }
    });
    document.getElementById('spacesSelect').addEventListener('change', (e) => {
      const sid = parseInt(e.target.value || '0', 10);
      state.spaceId = sid || state.spaceId;
      // Switch to a separate conversation per-space; resume from storage on next open
      dr.conversationId = null;
    });

    // Search
    function renderResults(hits, query) {
      const wrap = document.getElementById('results');
      const row = document.getElementById('resultsRow');
      wrap.innerHTML = '';
      const limited = Array.isArray(hits) ? hits.slice(0, 10) : [];
      if (!limited.length) {
        row.hidden = false;
        wrap.textContent = 'No results';
        return;
      }
      const items = limited.map((h, idx) => {
        const title = h.title ? escapeHtml(h.title) : '';
        const fname = h.file_name ? escapeHtml(h.file_name) : '';
        const label = title || fname || '(untitled)';
        const distance = (h.distance !== null && h.distance !== undefined) ? `distance: ${h.distance.toFixed ? h.distance.toFixed(4) : h.distance}` : '';
        const rank = (h.rank !== null && h.rank !== undefined) ? `rank: ${h.rank.toFixed ? h.rank.toFixed(4) : h.rank}` : '';
        const badges = `${distance ? `<span class="badge">${distance}</span>` : ''}${rank ? `<span class="badge">${rank}</span>` : ''}`;
        return `<div class="hit"><details><summary>[${idx + 1}] ${label} ${badges}</summary><div class="hit-content">${highlight(h.content || '', query)}</div></details></div>`;
      }).join('');
      wrap.innerHTML = items;
      row.hidden = false;
    }

    let currentSearchController = null;
    let searchTimer = null;

    async function doSearch() {
      const query = document.getElementById('query').value.trim();
      const mode = document.getElementById('mode').value;
      const topk = parseInt(document.getElementById('topk').value || '25', 10);
      const ans = document.getElementById('answer');
      const answerRow = document.getElementById('answerRow');
      const loading = document.getElementById('searchLoading');
      const btn = document.getElementById('searchBtn');

      if (!query) { ans.textContent = ''; renderResults([], ''); return; }

      if (currentSearchController) currentSearchController.abort();
      const ctrl = new AbortController();
      currentSearchController = ctrl;

      loading.hidden = false;
      btn.disabled = true;
      ans.textContent = '';

      try {
        const provider = document.getElementById('provider')?.value || undefined;
        const data = await api('/api/search', { method: 'POST', body: { query, mode, top_k: topk, space_id: state.spaceId, llm_provider: provider }, signal: ctrl.signal });

        if (data.answer) {
          ans.textContent = data.answer;
          answerRow.hidden = false;
          const badge = document.getElementById('llmBadge');
          if (badge) {
            if (data.used_llm === true) {
              badge.textContent = 'LLM answer';
              badge.style.display = 'inline-block';
            } else {
              badge.textContent = 'Context-only';
              badge.style.display = 'inline-block';
            }
          }
          const refsEl = document.getElementById('refs');
          const refsLabel = document.getElementById('refsLabel');
          if (refsEl) {
            if (Array.isArray(data.references) && data.references.length) {
              const limitedRefs = data.references.slice(0, 10);
              refsEl.style.display = 'grid';
              if (refsLabel) refsLabel.style.display = 'block';
              const items = limitedRefs.map((r, idx) => {
                const fn = r.file_name || '';
                const ft = r.file_type || '';
                const docId = r.doc_id || null;
                const link = docId ? `<a href="/api/doc-download?doc_id=${docId}" target="_blank" rel="noopener" data-doc-id="${docId}">Download source</a>` : '';
                const match = data.hits.find(h => h.chunk_id === r.chunk_id);
                const txt = match ? highlight(match.content || '', query) : '';
                return `<div class="hit"><details><summary>[${idx+1}] ${escapeHtml(fn)}${ft ? ` (${escapeHtml(ft)})` : ''} ${link}</summary><div class="hit-content">${txt}</div></details></div>`;
              }).join('');
              refsEl.innerHTML = items;
            } else {
              refsEl.style.display = 'none';
              if (refsLabel) refsLabel.style.display = 'none';
              refsEl.innerHTML = '';
            }
          }
        }
        renderResults(data.hits, query);
      } catch (e) {
        if (e.name !== 'AbortError') {
          showToast('Search failed');
          console.error(e);
        }
      } finally {
        if (currentSearchController === ctrl) currentSearchController = null;
        loading.hidden = true;
        btn.disabled = false;
      }
    }

    document.addEventListener('keydown', (e) => {
      const q = document.getElementById('query');
      if (e.key === 'Enter' && document.activeElement === q) {
        e.preventDefault();
        doSearch();
      } else if (e.key === 'Escape') {
        q.value = '';
        document.getElementById('answer').textContent = '';
        document.getElementById('answerRow').hidden = true;
        const res = document.getElementById('results');
        res.innerHTML = '';
        document.getElementById('resultsRow').hidden = true;
      }
    });

    document.getElementById('searchBtn').addEventListener('click', () => doSearch());

    // Deep Research UI
    let dr = { open: false, conversationId: null };
    function drStorageKey(spaceId) { return `dr:space:${spaceId || '_'}`; }

    function openDr() {
      const m = document.getElementById('drModal');
      const b = document.getElementById('drBackdrop');
      if (b) b.hidden = false;
      if (m) m.hidden = false;
      dr.open = true;
      document.getElementById('drMessage')?.focus();
    }
    function closeDr() {
      const m = document.getElementById('drModal');
      const b = document.getElementById('drBackdrop');
      if (b) b.hidden = true;
      if (m) m.hidden = true;
      dr.open = false;
    }
    async function ensureDrConversation() {
      if (dr.conversationId) return dr.conversationId;
      // Try to resume previous conversation per-space
      const key = drStorageKey(state.spaceId);
      try {
        const saved = localStorage.getItem(key);
        if (saved) { dr.conversationId = saved; return saved; }
      } catch {}
      const payload = { space_id: state.spaceId };
      const r = await api('/api/deep-research/start', { method: 'POST', body: payload });
      dr.conversationId = r.conversation_id;
      try { localStorage.setItem(key, dr.conversationId); } catch {}
      return dr.conversationId;
    }
    async function resetDr() {
      try {
        const key = drStorageKey(state.spaceId);
        try { localStorage.removeItem(key); } catch {}
        const payload = { space_id: state.spaceId };
        const r = await api('/api/deep-research/start', { method: 'POST', body: payload });
        dr.conversationId = r.conversation_id;
        try { localStorage.setItem(key, dr.conversationId); } catch {}
        const chat = document.getElementById('drChat');
        if (chat) chat.innerHTML = '';
        showToast('Started a new Deep Research conversation');
      } catch (e) {
        showToast('Failed to reset conversation');
      }
    }
    function pushMsg(role, text) {
      const chat = document.getElementById('drChat');
      const div = document.createElement('div');
      div.className = 'dr-msg ' + (role === 'user' ? 'me' : 'ai');
      const content = role === 'assistant' ? renderLLMText(text) : `<p>${escapeHtml(text)}</p>`;
      div.innerHTML = `<div class="bubble">${content}</div>`;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }
    async function sendDr() {
      const inp = document.getElementById('drMessage');
      const txt = (inp.value || '').trim();
      if (!txt) return;
      inp.value = '';
      pushMsg('user', txt);
      // Show thinking indicator (animated dots only, no bubble)
      const chat = document.getElementById('drChat');
      const th = document.createElement('div');
      th.className = 'dr-thinking-inline';
      th.innerHTML = `<span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>`;
      chat.appendChild(th);
      chat.scrollTop = chat.scrollHeight;
      try {
        const cid = await ensureDrConversation();
        const provider = document.getElementById('provider')?.value || undefined;
        const body = { conversation_id: cid, message: txt, space_id: state.spaceId, llm_provider: provider };
        const r = await api('/api/deep-research/ask', { method: 'POST', body });
        const ans = (r && r.answer) ? String(r.answer) : '(no answer)';
        // Replace thinking bubble with answer
        if (th && th.parentElement) th.parentElement.removeChild(th);
        pushMsg('assistant', ans);
      } catch (e) {
        if (th && th.parentElement) th.parentElement.removeChild(th);
        pushMsg('assistant', 'Sorry, something went wrong.');
      }
    }

    document.getElementById('drBtn')?.addEventListener('click', async () => { try { await ensureDrConversation(); } catch {} openDr(); });
    document.getElementById('drClose')?.addEventListener('click', () => closeDr());
    document.getElementById('drReset')?.addEventListener('click', async () => { await resetDr(); });
    document.getElementById('drSend')?.addEventListener('click', () => sendDr());
    document.getElementById('drMessage')?.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendDr(); } });
    document.getElementById('drBackdrop')?.addEventListener('click', () => closeDr());

    document.getElementById('query').addEventListener('input', () => {
      const auto = document.getElementById('autoSearch')?.checked ?? false;
      const delay = parseInt(document.getElementById('debounceMs')?.value || '400', 10);
      if (auto) {
        clearTimeout(searchTimer);
        searchTimer = setTimeout(() => doSearch().catch(console.error), delay);
      }
    });

    document.getElementById('mode').addEventListener('change', () => {
      if (document.getElementById('autoSearch').checked) doSearch();
    });
    document.getElementById('topk').addEventListener('change', () => {
      if (document.getElementById('autoSearch').checked) doSearch();
    });

    document.getElementById('settingsBtn').addEventListener('click', () => {
      const p = document.getElementById('settingsPanel');
      const b = document.getElementById('settingsBtn');
      const nowHidden = !p.hidden;
      p.hidden = nowHidden;
      b.setAttribute('aria-expanded', String(!nowHidden));
    });

    async function loadProviders() {
      try {
        const p = await api('/api/providers');
        const sel = document.getElementById('provider');
        if (sel && p && Array.isArray(p.supported)) {
          const keep = sel.value;
          sel.innerHTML = '';
          const opt0 = document.createElement('option'); opt0.value = ''; opt0.textContent = 'Default'; sel.appendChild(opt0);
          for (const v of p.supported) { const o = document.createElement('option'); o.value = v; o.textContent = v.toUpperCase(); sel.appendChild(o); }
          const preferred = 'bedrock';
          sel.value = keep || (p.supported.includes(preferred) ? preferred : '');
        }
      } catch {}
    }

    async function loadSearchConfig() {
      try {
        const cfg = await api('/api/search-config');
        const be = document.getElementById('cfgBackend'); if (be) be.textContent = cfg.backend || '-';
        const t = document.getElementById('cfgTopK'); if (t) t.value = cfg.default_top_k != null ? String(cfg.default_top_k) : '';
        const tk = document.getElementById('topk'); if (tk && cfg.default_top_k != null) tk.value = String(cfg.default_top_k);
        const pgRow = document.getElementById('cfgPgvectorRow');
        const osRow = document.getElementById('cfgNumCandRow');
        const pgv = document.getElementById('cfgProbes');
        const ncd = document.getElementById('cfgNumCand');
        if (cfg.backend === 'pgvector') {
          if (pgRow) pgRow.hidden = false; if (osRow) osRow.hidden = true;
          if (pgv) pgv.value = cfg.pgvector_probes != null ? String(cfg.pgvector_probes) : '';
        } else {
          if (pgRow) pgRow.hidden = true;
          const engine = (cfg.opensearch?.engine || 'lucene').toLowerCase();
          if (osRow) osRow.hidden = engine === 'lucene';
          if (ncd) ncd.value = cfg.opensearch?.num_candidates != null ? String(cfg.opensearch.num_candidates) : '';
        }
      } catch (e) {
        // ignore (likely 401 if not logged-in yet)
      }
    }

    async function saveSearchConfig() {
      try {
        const t = document.getElementById('cfgTopK');
        const pgv = document.getElementById('cfgProbes');
        const ncd = document.getElementById('cfgNumCand');
        const body = {};
        if (t && t.value !== '') body.default_top_k = parseInt(t.value, 10);
        if (pgv && !pgv.parentElement.hidden) body.pgvector_probes = pgv.value === '' ? null : parseInt(pgv.value, 10);
        if (ncd && !ncd.parentElement.hidden) body.os_num_candidates = ncd.value === '' ? null : parseInt(ncd.value, 10);
        const resp = await api('/api/search-config', { method: 'POST', body });
        if (resp && resp.ok) { showToast('Saved'); await loadSearchConfig(); }
      } catch (e) {
        showToast('Save failed');
      }
    }

    const loadCfgBtn = document.getElementById('loadCfgBtn');
    if (loadCfgBtn) loadCfgBtn.addEventListener('click', () => loadSearchConfig());
    const saveCfgBtn = document.getElementById('saveCfgBtn');
    if (saveCfgBtn) saveCfgBtn.addEventListener('click', () => saveSearchConfig());

    // Knowledge Base logic
    async function fetchDocUrl(docId) {
      try {
        const r = await api(`/api/doc-url?doc_id=${encodeURIComponent(docId)}`);
        if (r && r.url) return r.url;
      } catch (e) {}
      return null;
    }

    let kbOrder = 'desc';

    async function loadKB() {
      try {
        const qsParts = [];
        if (state.spaceId) qsParts.push(`space_id=${encodeURIComponent(state.spaceId)}`);
        if (kbOrder) qsParts.push(`order=${encodeURIComponent(kbOrder)}`);
        const qs = qsParts.length ? `?${qsParts.join('&')}` : '';
        const data = await api(`/api/kb${qs}`);
        const list = document.getElementById('kbList');
        const sec = document.getElementById('kbSection');
        list.innerHTML = '';
        if (Array.isArray(data.documents) && data.documents.length) {
          for (const d of data.documents) {
            const div = document.createElement('div');
            div.className = 'hit';
            const link = `<a href="#" data-doc-id="${d.id}">${escapeHtml(d.file_name || d.title || ('doc ' + d.id))}</a>`;
            div.innerHTML = `
              <div class="hit-row">
                <div class="hit-left">
                  <input type="checkbox" class="kbSel" data-doc-id="${d.id}" aria-label="Select document" />
                  &nbsp; ${link}
                </div>
                <div class="hit-right">
                  <span class="badge">${escapeHtml(d.source_type || '')}</span>
                  <span class="badge">${(d.chunk_count != null ? (d.chunk_count + ' chunks') : '')}</span>
                  ${d.created_at ? `<span class="badge">${escapeHtml(new Date(d.created_at).toLocaleString())}</span>` : ''}
                  <button class="ghost" data-delete-doc-id="${d.id}">Delete</button>
                </div>
              </div>`;
            list.appendChild(div);
          }
        } else {
          list.textContent = 'No documents yet.';
        }
        sec.hidden = false;
        window.scrollTo({ top: sec.offsetTop - 16, behavior: 'smooth' });
      } catch (e) {
        showToast('Failed to load knowledge base');
      }
    }

    document.addEventListener('click', async (e) => {
      const a = e.target.closest('a[data-doc-id]');
      if (a) {
        e.preventDefault();
        const docId = a.getAttribute('data-doc-id');
        window.open(`/api/doc-download?doc_id=${encodeURIComponent(docId)}`, '_blank');
      }
    });

    const kbRefreshBtn = document.getElementById('kbRefreshBtn');
    if (kbRefreshBtn) kbRefreshBtn.addEventListener('click', () => loadKB());

    const kbSortBtn = document.getElementById('kbSortBtn');
    if (kbSortBtn) kbSortBtn.addEventListener('click', () => {
      kbOrder = (kbOrder === 'desc') ? 'asc' : 'desc';
      kbSortBtn.textContent = kbOrder === 'desc' ? 'Latest first' : 'Oldest first';
      loadKB();
    });

    // KB delete single
    document.addEventListener('click', async (e) => {
      const btn = e.target.closest('button[data-delete-doc-id]');
      if (btn) {
        e.preventDefault();
        const id = btn.getAttribute('data-delete-doc-id');
        const ok = confirm('Are you sure you want to delete this file?');
        if (!ok) return;
        try {
          const res = await fetch(`/api/admin/documents/${encodeURIComponent(id)}`, { method: 'DELETE' });
          if (res.ok) { showToast('Deleted'); await loadKB(); } else { showToast('Delete failed'); }
        } catch { showToast('Delete failed'); }
      }
    });

    // KB bulk select/delete
    const kbSelectAll = document.getElementById('kbSelectAll');
    if (kbSelectAll) kbSelectAll.addEventListener('change', () => {
      const boxes = document.querySelectorAll('input.kbSel');
      boxes.forEach(b => { b.checked = kbSelectAll.checked; });
    });
    const kbDeleteSelectedBtn = document.getElementById('kbDeleteSelectedBtn');
    if (kbDeleteSelectedBtn) kbDeleteSelectedBtn.addEventListener('click', async () => {
      const boxes = Array.from(document.querySelectorAll('input.kbSel:checked'));
      if (!boxes.length) { showToast('No selection'); return; }
      const ok = confirm(`Are you sure you want to delete ${boxes.length} file(s)?`);
      if (!ok) return;
      for (const b of boxes) {
        const id = b.getAttribute('data-doc-id');
        try { await fetch(`/api/admin/documents/${encodeURIComponent(id)}`, { method: 'DELETE' }); } catch {}
      }
      showToast('Delete requested');
      await loadKB();
    });

    // Drag-and-drop support
    const dropzone = document.getElementById('dropzone');
    const dzStatus = document.getElementById('dzStatus');
    let droppedFiles = [];

    let ALLOWED_EXTS = new Set([".pdf",".txt",".csv",".md",".json",".html",".htm",".docx",".pptx",".xlsx",".png",".jpg",".jpeg",".tif",".tiff",".bmp",".gif"]);
    let SUPPORTED_TYPES_TXT = 'PDF, DOCX, PPTX, XLSX, TXT, HTML, CSV, MD, JSON, PNG, JPG, JPEG, TIFF, BMP, GIF';
    let MAX_FILES = 100;
    let MAX_BYTES = 50 * 1024 * 1024; // 50MB

    async function loadUploadConfig() {
      try {
        const cfg = await api('/api/upload-config');
        if (cfg && typeof cfg === 'object') {
          if (Array.isArray(cfg.allowed_extensions) && cfg.allowed_extensions.length) {
            ALLOWED_EXTS = new Set(cfg.allowed_extensions.map(e => String(e).toLowerCase()));
            const list = Array.from(ALLOWED_EXTS).map(e => e.replace(/^\./, '').toUpperCase());
            SUPPORTED_TYPES_TXT = list.join(', ');
          }
          if (cfg.max_upload_files != null) {
            MAX_FILES = parseInt(cfg.max_upload_files, 10) || MAX_FILES;
          }
          if (cfg.max_upload_size_mb != null) {
            MAX_BYTES = (parseInt(cfg.max_upload_size_mb, 10) || 50) * 1024 * 1024;
          }
          const hint = document.getElementById('dzHint');
          if (hint) hint.textContent = `Maximum ${Math.round(MAX_BYTES/1024/1024)}MB per file ‚Ä¢ Maximum ${MAX_FILES} files per batch`;
        }
      } catch (e) {
        // ignore, keep defaults
      }
    }

    function addFilesToList(fileList, opts = { isFolder: false }) {
      const added = [];
      const skipped = [];
      let skippedType = 0;
      let skippedSize = 0;
      for (const f of fileList) {
        if (droppedFiles.length + added.length >= MAX_FILES) { skipped.push(`${f.name} (limit reached)`); continue; }
        const ext = ('.' + (f.name.split('.').pop() || '')).toLowerCase();
        if (!ALLOWED_EXTS.has(ext)) { skipped.push(`${f.name} (type)`); skippedType++; continue; }
        if (f.size > MAX_BYTES) { skipped.push(`${f.name} (size)`); skippedSize++; continue; }
        added.push(f);
      }
      droppedFiles.push(...added);
      if (dzStatus) dzStatus.textContent = droppedFiles.length ? `${droppedFiles.length} file(s) ready` : 'Drop files here or use the file chooser below';
      if (opts.isFolder && (skippedType > 0 || (fileList.length + (droppedFiles.length - added.length)) > MAX_FILES)) {
        showToast(`Folder contains unsupported types or too many files. Please upload a folder with 100 files or less and only supported types: ${SUPPORTED_TYPES_TXT}.`);
      } else if (skipped.length) {
        showToast(`Some files skipped: ${skipped.slice(0,3).join(', ')}${skipped.length>3?'‚Ä¶':''}`);
      } else {
        showToast(`${droppedFiles.length} file(s) ready`);
      }
    }

    async function traverseEntry(entry) {
      return new Promise((resolve) => {
        if (entry.isFile) {
          entry.file(file => resolve([file]));
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          const out = [];
          const read = () => reader.readEntries(async entries => {
            if (!entries.length) return resolve(out);
            for (const e of entries) {
              const nested = await traverseEntry(e);
              out.push(...nested);
            }
            read();
          });
          read();
        } else {
          resolve([]);
        }
      });
    }

    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.classList.remove('dragover');
      const items = e.dataTransfer.items;
      let isFolder = false;
      if (items && items.length && items[0].webkitGetAsEntry) {
        let all = [];
        for (const it of items) {
          const entry = it.webkitGetAsEntry();
          if (entry) {
            if (entry.isDirectory) isFolder = true;
            const files = await traverseEntry(entry);
            all.push(...files);
          }
        }
        addFilesToList(all, { isFolder });
      } else {
        addFilesToList(e.dataTransfer.files, { isFolder: false });
      }
    });

    const filesInputEl = document.getElementById('files');
    if (filesInputEl) {
      filesInputEl.addEventListener('change', () => {
        const count = filesInputEl.files ? filesInputEl.files.length : 0;
        const badge = document.getElementById('fileSelectionText');
        if (badge) badge.textContent = count ? `${count} file(s) selected.` : 'No files selected.';
        if (dzStatus) dzStatus.textContent = count ? `${count} file(s) selected` : 'Drop files here or use the file chooser below';
      });
    }

    // Upload with per-file progress and space_id
    const clearBtn = document.getElementById('clearUploadBtn');
    if (clearBtn) clearBtn.addEventListener('click', () => {
      try {
        const files = document.getElementById('files');
        const status = document.getElementById('uploadStatus');
        const list = document.getElementById('uploadList');
        const listRow = document.getElementById('uploadListRow');
        const statusRow = document.getElementById('uploadStatusRow');
        const badge = document.getElementById('fileSelectionText');
        if (files) files.value = '';
        if (status) status.textContent = '';
        if (list) list.innerHTML = '';
        if (listRow) listRow.hidden = true;
        if (statusRow) statusRow.hidden = true;
        droppedFiles = [];
        if (dzStatus) dzStatus.textContent = 'Drop files here or use the file chooser below';
        if (badge) badge.textContent = 'No files selected.';
        showToast('Cleared');
      } catch {}
    });

    document.getElementById('uploadBtn').addEventListener('click', async () => {
      if (!state.user) { showToast('Login required'); return; }
      const filesInput = document.getElementById('files');
      const status = document.getElementById('uploadStatus');
      const statusRow = document.getElementById('uploadStatusRow');
      const loading = document.getElementById('uploadLoading');
      const list = document.getElementById('uploadList');
      const listRow = document.getElementById('uploadListRow');
      status.textContent = '';

      const selA = filesInput?.files ? Array.from(filesInput.files) : [];
      let allFiles = [...selA, ...droppedFiles];
      if (!allFiles.length) { showToast('No files selected'); return; }
      // Filter client-side as well
      const filtered = [];
      for (const f of allFiles) {
        const ext = ('.' + (f.name.split('.').pop() || '')).toLowerCase();
        if (!ALLOWED_EXTS.has(ext)) continue;
        if (f.size > MAX_BYTES) continue;
        filtered.push(f);
        if (filtered.length >= MAX_FILES) break;
      }
      allFiles = filtered;
      if (!allFiles.length) { showToast('No valid files to upload'); return; }

      list.innerHTML = '';
      listRow.hidden = false;
      statusRow.hidden = false;
      const entries = new Map();
      for (const f of allFiles) {
        const item = document.createElement('div');
        item.className = 'progress-item';
        item.innerHTML = `
          <div class="progress-row"><span>${escapeHtml(f.webkitRelativePath || f.name)}</span><span class="pct">0%</span></div>
          <div class="progress"><div class="progress-bar"></div></div>
        `;
        list.appendChild(item);
        entries.set(f, item);
      }

      loading.hidden = false;

      const maxRetries = 3;
      const backoff = (attempt) => Math.min(2000, 300 * Math.pow(2, attempt - 1));

      function uploadOne(file, attempt = 1) {
        return new Promise((resolve) => {
          const item = entries.get(file);
          const bar = item.querySelector('.progress-bar');
          const pctLabel = item.querySelector('.pct');
          const xhr = new XMLHttpRequest();
          xhr.open('POST', '/api/upload');

          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const pct = Math.round((e.loaded / e.total) * 100);
              bar.style.width = pct + '%';
              pctLabel.textContent = pct + '%';
            } else {
              bar.style.width = '50%';
              pctLabel.textContent = '‚Ä¶';
            }
          };
          xhr.upload.onload = () => { pctLabel.textContent = 'processing‚Ä¶'; };

          xhr.onerror = () => {
            if (attempt < maxRetries) {
              const delay = backoff(attempt);
              pctLabel.textContent = `retrying (${attempt}/${maxRetries})‚Ä¶`;
              setTimeout(() => resolve(uploadOne(file, attempt + 1)), delay);
            } else { pctLabel.textContent = 'failed'; resolve({ file, ok: false, error: 'network error' }); }
          };

          xhr.onreadystatechange = function () {
            if (xhr.readyState === XMLHttpRequest.DONE) {
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  const data = JSON.parse(xhr.responseText);
                  bar.style.width = '100%';
                  pctLabel.textContent = '100%';
                  try {
                    const res = Array.isArray(data.results) ? data.results[0] : data;
                    if (res && typeof res === 'object') {
                      const docId = res.document_id || res.documentId;
                      const chunks = res.chunks || res.num_chunks;
                      const msg = [];
                      if (docId != null) msg.push(`doc ${docId}`);
                      if (chunks != null) msg.push(`${chunks} chunks`);
                      const row = item.querySelector('.progress-row span');
                      if (row && msg.length) row.textContent = `${row.textContent} ‚Äî processed (${msg.join(', ')})`;
                    }
                  } catch {}
                  resolve({ file, ok: true, data });
                } catch (e) {
                  if (attempt < maxRetries) {
                    const delay = backoff(attempt);
                    pctLabel.textContent = `retrying (${attempt}/${maxRetries})‚Ä¶`;
                    setTimeout(() => resolve(uploadOne(file, attempt + 1)), delay);
                  } else { pctLabel.textContent = 'failed'; resolve({ file, ok: false, error: 'parse error' }); }
                }
              } else if (xhr.status >= 500 && attempt < maxRetries) {
                const delay = backoff(attempt);
                pctLabel.textContent = `retrying (${attempt}/${maxRetries})‚Ä¶`;
                setTimeout(() => resolve(uploadOne(file, attempt + 1)), delay);
              } else {
                pctLabel.textContent = 'failed';
                resolve({ file, ok: false, error: xhr.responseText || `HTTP ${xhr.status}` });
              }
            }
          };

          const form = new FormData();
          form.append('files', file);
          if (state.spaceId) form.append('space_id', String(state.spaceId));
          xhr.send(form);
        });
      }

      const queue = [...allFiles];
      const inFlight = new Set();
      const results = [];

      async function pump() {
        while (inFlight.size < 4 && queue.length) {
          const f = queue.shift();
          const p = uploadOne(f).then((res) => {
            inFlight.delete(p);
            results.push(res);
            pump();
          });
          inFlight.add(p);
        }
        if (!queue.length && !inFlight.size) {
          loading.hidden = true;
          try {
            const items = results.map(r => {
              const name = r.file.webkitRelativePath || r.file.name;
              const icon = r.ok ? '‚úÖ' : '‚ùå';
              const err = r.error ? ` ‚Äî ${String(r.error)}` : '';
              return `<div>${icon} ${escapeHtml(name)}${err}</div>`;
            }).join('');
            status.innerHTML = items || 'Upload finished';
            showToast('Upload finished');
          } catch (e) {
            status.textContent = 'Upload finished';
          }
          droppedFiles = [];
          try { await loadKB(); } catch {}
        }
      }

      pump();
    });

    // Initialize
    function setupCollapsible(toggleId, contentId) {
      const t = document.getElementById(toggleId);
      const c = document.getElementById(contentId);
      if (!t || !c) return;
      const caret = t.querySelector('.caret');
      t.addEventListener('click', () => {
        const expanded = t.getAttribute('aria-expanded') === 'true';
        t.setAttribute('aria-expanded', String(!expanded));
        c.hidden = expanded;
        if (caret) caret.style.transform = expanded ? 'rotate(0deg)' : 'rotate(90deg)';
      });
    }

    window.addEventListener('DOMContentLoaded', async () => {
      const q = document.getElementById('query');
      const files = document.getElementById('files');
      const status = document.getElementById('uploadStatus');
      const badge = document.getElementById('fileSelectionText');
      if (q) q.value = '';
      if (files) files.value = '';
      if (status) status.textContent = '';
      if (dzStatus) dzStatus.textContent = 'Drop files here or use the file chooser below';
      if (badge) badge.textContent = 'No files selected.';
      droppedFiles = [];
      await initUser();
      await loadProviders();
      await loadSearchConfig();
      await loadUploadConfig();
      if (state && state.user) { try { await loadKB(); } catch (e) {} }
      setupCollapsible('kbToggle', 'kbContent');
      setupCollapsible('uploadToggle', 'uploadContent');
    });
  </script>
</body>
</html>