<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SpacesAI</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <header class="topbar">
    <h4>SpacesAI ‚Ä¢ Personal Knowledge Spaces with RAG</h4>
    <div class="spacer"></div>
    <div id="userControls" class="user-controls" hidden>
      <span id="userEmail" class="user-email"></span>
      <button id="logoutBtn" class="ghost" title="Logout">Logout</button>
    </div>
    <button id="themeBtn" class="ghost" title="Toggle dark mode">üåì</button>
  </header>

  <main class="container">
    <!-- Hero and Auth -->
    <section class="card card--wide hero">
      <div class="logo" aria-label="SPACES" style="text-align:center">
        <span class="g g-blue">S</span>
        <span class="g g-red">P</span>
        <span class="g g-yellow">A</span>
        <span class="g g-blue">C</span>
        <span class="g g-green">E</span>
        <span class="g g-red">S</span>
      </div>

      <div id="authPanel" class="auth" hidden>
        <div class="row cols">
          <div class="auth-card" id="loginCard">
            <h3>Sign in</h3>
            <label class="block">Email</label>
            <input id="loginEmail" type="email" placeholder="you@example.com" />
            <label class="block">Password</label>
            <input id="loginPassword" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
            <button id="loginBtn" class="primary">Login</button>
            <p class="small">New here? <a href="#" id="showRegisterLink">Create account</a></p>
          </div>
          <div class="auth-card" id="registerCard" hidden>
            <h3>Create account</h3>
            <label class="block">Email</label>
            <input id="regEmail" type="email" placeholder="you@example.com" />
            <label class="block">Password</label>
            <input id="regPassword" type="password" placeholder="At least 8 characters" />
            <button id="registerBtn">Register</button>
            <p class="small"><a href="#" id="cancelRegisterLink">Back to sign in</a></p>
          </div>
        </div>
      </div>

      <div id="appPanel" class="app-panel" hidden>


        <section id="unifiedSearchPanel" class="search-panel" role="region" aria-label="Search workspace">
          <div class="search-tabs" role="tablist" aria-label="Search mode">
            <button id="searchModeText" class="search-tab active" role="tab" aria-selected="true">Text Search</button>
            <button id="searchModeImage" class="search-tab" role="tab" aria-selected="false">Image Search <span class="beta-tag">Beta</span></button>
          </div>
          <div class="searchbar">
            <input id="searchInput" class="search-input" type="text" placeholder="Search documents‚Ä¶" autocomplete="off" />
            <button id="drBtn" class="dr-icon" title="Deep Research">üî¨</button>
          </div>
          <div class="search-actions-row">
            <button id="searchBtn" class="primary">Search</button>
            <button id="settingsBtn" class="ghost" title="Search settings" aria-expanded="false">‚öôÔ∏è</button>
          </div>

          <div id="settingsPanel" class="settings" hidden>
            <div id="textSettings" class="settings-pane">
              <div class="row wrap">
                <div class="row no-grow">
                  <label for="mode">Mode</label>
                  <select id="mode">
                    <option value="hybrid">Hybrid</option>
                    <option value="semantic">Semantic</option>
                    <option value="fulltext">Full-text</option>
                    <option value="rag" selected>RAG</option>
                  </select>
                </div>
                <div class="row no-grow">
                  <label for="provider" class="leftpad">LLM Provider</label>
                  <select id="provider">
                    <option value="">Default</option>
                    <option value="oci">OCI</option>
                    <option value="openai">OpenAI</option>
                    <option value="bedrock">Bedrock</option>
                    <option value="ollama">Ollama</option>
                  </select>
                </div>
                <div class="row no-grow">
                  <label for="topk" class="leftpad">Top K</label>
                  <input id="topk" type="number" value="25" min="1" max="50" />
                </div>
                <div class="row no-grow">
                  <label for="autoSearch" class="leftpad">Auto search</label>
                  <input id="autoSearch" type="checkbox" />
                  <label for="debounceMs" class="leftpad">Debounce (ms)</label>
                  <input id="debounceMs" type="number" value="400" min="100" max="2000" />
                </div>
              </div>
              <div class="row wrap">
                <div class="row no-grow">
                  <strong>Search backend:</strong>&nbsp;<span id="cfgBackend">-</span>
                </div>
                <div class="row no-grow">
                  <label for="cfgTopK" class="leftpad">Default Top K</label>
                  <input id="cfgTopK" type="number" min="1" max="1000" placeholder="25" />
                </div>
                <div class="row no-grow" id="cfgPgvectorRow" hidden>
                  <label for="cfgProbes" class="leftpad">pgvector probes</label>
                  <input id="cfgProbes" type="number" min="1" max="10000" placeholder="env default" />
                </div>
                <div class="row no-grow" id="cfgNumCandRow" hidden>
                  <label for="cfgNumCand" class="leftpad">OS num_candidates</label>
                  <input id="cfgNumCand" type="number" min="1" max="1000000" placeholder="heuristic default" />
                </div>
                <div class="row no-grow">
                  <button id="loadCfgBtn" class="ghost">Refresh config</button>
                  <button id="saveCfgBtn" class="ghost">Save</button>
                </div>
              </div>
              <div class="row wrap">
                <label for="spacesSelect">Space</label>
                <select id="spacesSelect"></select>
                <button id="setDefaultSpaceBtn" class="ghost">Set default</button>
                <span class="leftpad"></span>
                <input id="newSpaceName" placeholder="Create new space‚Ä¶" />
                <button id="createSpaceBtn">Create</button>
              </div>
            </div>

            <div id="imageSettings" class="settings-pane" hidden>
              <div class="row wrap">
                <div class="row no-grow">
                  <label class="block" for="imageTags">Tag filters (comma separated)</label>
                  <input id="imageTags" type="text" placeholder="policy, architecture" />
                </div>
                <div class="row no-grow">
                  <label class="block" for="imageTopK">Top K</label>
                  <input id="imageTopK" type="number" min="1" max="100" value="12" />
                </div>
                <div class="row no-grow">
                  <label class="block" for="imageThumbSize">Preview size</label>
                  <select id="imageThumbSize">
                    <option value="small">Small</option>
                    <option value="medium" selected>Medium</option>
                    <option value="large">Large</option>
                  </select>
                </div>
              </div>
              <div class="row wrap">
                <div class="row no-grow">
                  <label class="block" for="imageFile">Reference image (optional)</label>
                  <input id="imageFile" type="file" accept="image/png,image/jpeg,image/jpg,image/gif,image/webp,image/bmp" />
                </div>
                <div class="row no-grow">
                  <button id="imageClearBtn" class="ghost" type="button">Clear image inputs</button>
                </div>
              </div>
          <div class="muted"><strong>Beta:</strong> Image search is experimental‚Äîcombine descriptive text, tags, or a reference upload to improve similarity results.</div>
            </div>
          </div>
        </section>



        <div class="row middle">
          <div class="loader" id="searchLoading" hidden>
            <div class="spinner"></div>
            <span>Searching‚Ä¶</span>
          </div>
        </div>

        <div class="row" id="answerRow" hidden>
          <label>Answer / Context <span id="llmBadge" class="badge" style="display:none"></span></label>
          <pre id="answer" class="panel"></pre>
          <label id="refsLabel" style="display:none">References</label>
          <div id="refs" class="results" style="margin-top:8px; display:none"></div>
        </div>
        <div class="row" id="resultsRow" hidden>
          <label>Results</label>
          <div id="results" class="results"></div>
        </div>

        <div id="imageResultsSection" class="card card--wide" hidden>
          <div class="row middle" id="imageSearchLoading" hidden>
            <div class="spinner"></div>
            <span>Searching images‚Ä¶</span>
          </div>
          <div id="imageResultsEmpty" class="muted" hidden>No images yet. Try uploading visual assets or drag & drop a reference image.</div>
          <div id="imageResultsGrid" class="image-results-grid"></div>
        </div>
      </div>
    </section>

    <!-- Knowledge Base -->
    <section id="kbSection" class="card card--wide" hidden>
      <button class="collapsible-toggle" id="kbToggle" aria-expanded="false"><span class="caret">‚ñ∏</span> Your Knowledge Base</button>
      <div id="kbContent" hidden>
        <div class="row wrap">
          <button id="kbRefreshBtn" class="primary">Refresh</button>
          <button id="kbSortBtn" class="ghost" title="Toggle sort order" style="margin-left:8px">Latest first</button>
          <span class="leftpad"></span>
          <button id="kbDeleteSelectedBtn" class="ghost" title="Delete selected">Delete selected</button>
        </div>
        <div class="row">
          <label><input type="checkbox" id="kbSelectAll" /> Select all</label>
        </div>
        <div class="row">
          <div id="kbList" class="results"></div>
        </div>
      </div>
    </section>
    </section>

    <!-- Upload -->
    <section id="uploadSection" class="card card--wide" hidden>
      <button class="collapsible-toggle" id="uploadToggle" aria-expanded="false"><span class="caret">‚ñ∏</span> Upload to your Space</button>
      <div id="uploadContent" hidden>
        <div class="row wrap" style="width:100%; justify-content: space-between; align-items: center;">
          <div>
            <button id="uploadBtn" class="primary">Upload</button>
            <div class="loader" id="uploadLoading" hidden style="display:inline-flex; margin-left:8px;">
              <div class="spinner small"></div>
              <span>Processing‚Ä¶</span>
            </div>
          </div>
          <button id="clearUploadBtn" class="ghost" title="Clear uploads"><span class="refresh-icon">‚Üª</span></button>
        </div>
        <div class="row">
          <div id="dropzone" class="dropzone">
            <div class="dz-inner">
              <div class="dz-header">Drag & drop files</div>
              <div class="dz-desc">Documents: PDF, DOCX, PPTX, XLSX, TXT, HTML, CSV, MD, JSON ‚Ä¢ Images: PNG, JPG, JPEG, TIFF, BMP, GIF</div>
              <div class="dz-hint" id="dzHint">Maximum 50MB per file ‚Ä¢ Maximum 100 files per batch</div>
              <div class="dz-status" id="dzStatus">Drop files here or use the file chooser below</div>
              <div class="dz-meta" id="uploadStorageInfo"></div>
            </div>
          </div>
        </div>
        <div class="row">
          <input id="files" type="file" multiple accept=".pdf,.txt,.csv,.md,.json,.html,.htm,.docx,.pptx,.xlsx,.png,.jpg,.jpeg,.tif,.tiff,.bmp,.gif" />
        </div>
        <div class="row" id="uploadListRow" hidden>
          <div id="uploadList" class="progress-list"></div>
        </div>
        <div class="row" id="uploadStatusRow" hidden>
          <pre id="uploadStatus" class="panel"></pre>
        </div>
      </div>
    </section>
  </main>

  <div id="toast" class="toast" hidden></div>

  <div id="drBackdrop" class="dr-backdrop" hidden></div>
  <div id="drModal" class="dr-modal" hidden aria-modal="true" role="dialog">
    <div class="dr-header">
      <div style="display:flex; align-items:center; gap:10px" class="dr-title"><strong>Deep Research</strong><span class="microscope-icon">üî¨</span></div>
      <div style="display:flex; gap:6px; align-items:center">
        <button id="drReset" class="ghost" title="Reset conversation">‚Ü∫</button>
        <button id="drClose" class="ghost" title="Close">‚úï</button>
      </div>
    </div>
    <div id="drChat" class="dr-chat"></div>
    <div class="dr-input">
      <input id="drMessage" type="text" placeholder="Ask a question‚Ä¶" />
      <button id="drSend" class="primary">Send</button>
    </div>
  </div>

  <script>
    // Theme toggle
    (function(){
      const btn = document.getElementById('themeBtn');
      const curr = localStorage.getItem('theme');
      if (curr === 'dark') document.body.classList.add('dark');
      btn.addEventListener('click', () => {
        document.body.classList.toggle('dark');
        localStorage.setItem('theme', document.body.classList.contains('dark') ? 'dark' : 'light');
      });
    })();

    // Helpers
    function showToast(msg) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.hidden = false;
      setTimeout(() => { t.hidden = true; t.textContent = ''; }, 3000);
    }
    function escapeHtml(s) {
      return (s || '')
        .replace(/&/g, '&')
        .replace(/</g, '<')
        .replace(/>/g, '>')
        .replace(/\"/g, '"')
        .replace(/'/g, '&#039;');
    }
    function highlight(text, query) {
      if (!query) return escapeHtml(text);
      try {
        const esc = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const re = new RegExp(esc, 'ig');
        return escapeHtml(text).replace(re, m => `<mark>${escapeHtml(m)}</mark>`);
      } catch {
        return escapeHtml(text);
      }
    }
    function basename(path) {
      if (!path) return '';
      const idx = path.lastIndexOf('/');
      return idx >= 0 ? path.slice(idx + 1) : path;
    }
    function formatDocTitle(doc) {
      if (!doc) return '';
      return doc.title || doc.file_name || basename(doc.source_path) || `Document ${doc.id ?? ''}`.trim();
    }
    function formatDateLabel(value) {
      if (!value) return '';
      const dt = new Date(value);
      if (Number.isNaN(dt.getTime())) return '';
      return dt.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
    }
    function renderLLMText(s) {
      // Minimal markdown-ish renderer: code fences, lists, paragraphs
      const text = s || '';
      // Split code blocks
      const parts = text.split(/```/g);
      let html = '';
      for (let i = 0; i < parts.length; i++) {
        if (i % 2 === 1) {
          // code block
          html += `<pre class="code"><code>${escapeHtml(parts[i])}</code></pre>`;
        } else {
          // normal text -> handle lists and paragraphs
          const block = parts[i];
          const lines = block.split(/\r?\n/);
          let inUl = false, inOl = false;
          const out = [];
          const flushList = () => {
            if (inUl) { out.push('</ul>'); inUl = false; }
            if (inOl) { out.push('</ol>'); inOl = false; }
          };
          for (const raw of lines) {
            const ln = raw.trimEnd();
            if (/^\s*[-*]\s+/.test(ln)) {
              if (!inUl) { flushList(); out.push('<ul>'); inUl = true; }
              out.push(`<li>${escapeHtml(ln.replace(/^\s*[-*]\s+/, ''))}</li>`);
            } else if (/^\s*\d+\.\s+/.test(ln)) {
              if (!inOl) { flushList(); out.push('<ol>'); inOl = true; }
              out.push(`<li>${escapeHtml(ln.replace(/^\s*\d+\.\s+/, ''))}</li>`);
            } else if (ln.trim() === '') {
              flushList();
              out.push('<p></p>');
            } else {
              flushList();
              out.push(`<p>${escapeHtml(ln)}</p>`);
            }
          }
          flushList();
          html += out.join('');
        }
      }
      // Compact empty paragraphs
      html = html.replace(/(<p><\/p>\s*)+/g, '<p></p>');
      return html;
    }
    async function api(path, opts={}) {
      const isForm = opts.body instanceof FormData;
      const headers = opts.headers || (isForm ? undefined : { 'Content-Type': 'application/json' });
      const res = await fetch(path, {
        method: opts.method || 'GET',
        headers,
        body: opts.body ? (isForm ? opts.body : JSON.stringify(opts.body)) : undefined,
        signal: opts.signal,
      });
      if (!res.ok) throw new Error(await res.text());
      const ct = res.headers.get('content-type') || '';
      return ct.includes('application/json') ? await res.json() : await res.text();
    }

    // App state
    let state = {
      user: null,
      spaces: [],
      spaceId: null,
      imageSearchAbort: null,
    };

    function setLoggedInUI() {
      const auth = document.getElementById('authPanel');
      const app = document.getElementById('appPanel');
      const up = document.getElementById('uploadSection');
      const kb = document.getElementById('kbSection');
      const uc = document.getElementById('userControls');
      const emailEl = document.getElementById('userEmail');
      if (state.user) {
        auth.hidden = true;
        app.hidden = false;
        up.hidden = false;
        if (kb) { kb.hidden = false; }
        uc.hidden = false;
        emailEl.textContent = state.user.email;
      } else {
        auth.hidden = false;
        app.hidden = true;
        up.hidden = true;
        if (kb) { kb.hidden = true; }
        uc.hidden = true;
        emailEl.textContent = '';
      }
    }

    function populateSpaces() {
      const sel = document.getElementById('spacesSelect');
      sel.innerHTML = '';
      for (const s of state.spaces) {
        const opt = document.createElement('option');
        opt.value = String(s.id);
        opt.textContent = s.name + (s.is_default ? ' (default)' : '');
        sel.appendChild(opt);
      }
      if (state.spaceId) sel.value = String(state.spaceId);
    }

    async function initUser() {
      try {
        const me = await api('/api/me');
        if (me && me.user) {
          state.user = me.user;
          state.spaces = me.spaces || [];
          const def = (state.spaces.find(s => s.is_default) || {}).id;
          state.spaceId = def || (state.spaces[0] ? state.spaces[0].id : null);
          populateSpaces();
        } else {
          state.user = null;
          state.spaces = [];
          state.spaceId = null;
        }
      } catch (e) {
        state.user = null;
        state.spaces = [];
        state.spaceId = null;
      }
      setLoggedInUI();
    }

    // Auth handlers
    document.getElementById('loginBtn').addEventListener('click', async () => {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      try {
        const resp = await api('/api/login', { method: 'POST', body: { email, password } });
        state.user = resp.user; state.spaces = resp.spaces || [];
        const def = (state.spaces.find(s => s.is_default) || {}).id;
        state.spaceId = def || (state.spaces[0] ? state.spaces[0].id : null);
        populateSpaces(); setLoggedInUI(); await loadKB(); showToast('Logged in');
      } catch (e) {
        let msg = 'Login failed';
        try { const js = JSON.parse(e.message || '{}'); if (js && js.error) msg = js.error; } catch {}
        showToast(msg);
      }
    });
    document.getElementById('registerBtn').addEventListener('click', async () => {
      const email = document.getElementById('regEmail').value.trim();
      const password = document.getElementById('regPassword').value;
      try {
        const resp = await api('/api/register', { method: 'POST', body: { email, password } });
        // For SaaS-like UX: redirect users back to sign in (do not auto-login)
        try { await api('/api/logout', { method: 'POST' }); } catch {}
        state = { user: null, spaces: [], spaceId: null };
        // Prefill login email for convenience
        const le = document.getElementById('loginEmail'); if (le) le.value = email;
        // Toggle back to login view
        const loginCard = document.querySelector('#authPanel #loginCard');
        const regCard = document.getElementById('registerCard');
        if (loginCard) loginCard.hidden = false;
        if (regCard) regCard.hidden = true;
        setLoggedInUI();
        showToast('Account created. Please sign in.');
      } catch (e) {
        let msg = 'Registration failed';
        try { const js = JSON.parse(e.message || '{}'); if (js && js.error) msg = js.error; } catch {}
        showToast(msg);
      }
    });
    document.getElementById('logoutBtn').addEventListener('click', async () => {
      try { await api('/api/logout', { method: 'POST' }); } catch {}
      state = { user: null, spaces: [], spaceId: null };
      setLoggedInUI();
      // Clear stored Deep Research conversations on logout
      try { Object.keys(localStorage).forEach(k => { if (k.startsWith('dr:space:')) localStorage.removeItem(k); }); } catch {}
      showToast('Logged out');
    });

    // Auth UI toggles
    (function(){
      const loginCard = document.querySelector('#authPanel .auth-card:nth-child(1)');
      if (loginCard) loginCard.id = 'loginCard';
      const regCard = document.getElementById('registerCard');
      const showReg = document.getElementById('showRegisterLink');
      const cancelReg = document.getElementById('cancelRegisterLink');
      if (showReg) showReg.addEventListener('click', (e) => { e.preventDefault(); if (regCard) regCard.hidden = false; if (loginCard) loginCard.hidden = true; });
      if (cancelReg) cancelReg.addEventListener('click', (e) => { e.preventDefault(); if (regCard) regCard.hidden = true; if (loginCard) loginCard.hidden = false; });
    })();

    document.getElementById('createSpaceBtn').addEventListener('click', async () => {
      const name = document.getElementById('newSpaceName').value.trim();
      if (!name) return;
      try {
        const resp = await api('/api/spaces', { method: 'POST', body: { name } });
        await initUser();
        document.getElementById('newSpaceName').value = '';
        showToast('Space created');
      } catch (e) { showToast('Failed to create space'); }
    });
    document.getElementById('setDefaultSpaceBtn').addEventListener('click', async () => {
      const sel = document.getElementById('spacesSelect');
      const sid = parseInt(sel.value || '0', 10);
      if (!sid) return;
      try {
        await api('/api/spaces/default', { method: 'POST', body: { space_id: sid } });
        await initUser();
        showToast('Default space updated');
      } catch (e) { showToast('Failed to set default'); }
    });
    document.getElementById('spacesSelect').addEventListener('change', (e) => {
      const sid = parseInt(e.target.value || '0', 10);
      state.spaceId = sid || state.spaceId;
      // Switch to a separate conversation per-space; resume from storage on next open
      dr.conversationId = null;
    });

    // Search
    function renderResults(hits, query) {
      const wrap = document.getElementById('results');
      const row = document.getElementById('resultsRow');
      wrap.innerHTML = '';
      const limited = Array.isArray(hits) ? hits.slice(0, 10) : [];
      if (!limited.length) {
        row.hidden = false;
        wrap.textContent = 'No results';
        return;
      }
      const items = limited.map((h, idx) => {
        const title = h.title ? escapeHtml(h.title) : '';
        const fname = h.file_name ? escapeHtml(h.file_name) : '';
        const label = title || fname || '(untitled)';
        const distance = (h.distance !== null && h.distance !== undefined) ? `distance: ${h.distance.toFixed ? h.distance.toFixed(4) : h.distance}` : '';
        const rank = (h.rank !== null && h.rank !== undefined) ? `rank: ${h.rank.toFixed ? h.rank.toFixed(4) : h.rank}` : '';
        const badges = `${distance ? `<span class="badge">${distance}</span>` : ''}${rank ? `<span class="badge">${rank}</span>` : ''}`;
        return `<div class="hit"><details><summary>[${idx + 1}] ${label} ${badges}</summary><div class="hit-content">${highlight(h.content || '', query)}</div></details></div>`;
      }).join('');
      wrap.innerHTML = items;
      row.hidden = false;
    }

    let currentSearchController = null;
    let searchTimer = null;

    async function doSearch() {
      const query = searchInputEl.value.trim();
      const mode = document.getElementById('mode').value;
      const topk = parseInt(document.getElementById('topk').value || '25', 10);
      const ans = document.getElementById('answer');
      const answerRow = document.getElementById('answerRow');
      const loading = document.getElementById('searchLoading');
      const btn = document.getElementById('searchBtn');

      if (!query) { ans.textContent = ''; renderResults([], ''); return; }

      if (currentSearchController) currentSearchController.abort();
      const ctrl = new AbortController();
      currentSearchController = ctrl;

      loading.hidden = false;
      btn.disabled = true;
      ans.textContent = '';

      try {
        const provider = document.getElementById('provider')?.value || undefined;
        const data = await api('/api/search', { method: 'POST', body: { query, mode, top_k: topk, space_id: state.spaceId, llm_provider: provider }, signal: ctrl.signal });

        if (data.answer) {
          ans.textContent = data.answer;
          answerRow.hidden = false;
          const badge = document.getElementById('llmBadge');
          if (badge) {
            if (data.used_llm === true) {
              badge.textContent = 'LLM answer';
              badge.style.display = 'inline-block';
            } else {
              badge.textContent = 'Context-only';
              badge.style.display = 'inline-block';
            }
          }
          const refsEl = document.getElementById('refs');
          const refsLabel = document.getElementById('refsLabel');
          if (refsEl) {
            if (Array.isArray(data.references) && data.references.length) {
              const limitedRefs = data.references.slice(0, 10);
              refsEl.style.display = 'grid';
              if (refsLabel) refsLabel.style.display = 'block';
              const items = limitedRefs.map((r, idx) => {
                const fn = r.file_name || '';
                const ft = r.file_type || '';
                const docId = r.doc_id || null;
                const link = docId ? `<a href="/api/doc-download?doc_id=${docId}" target="_blank" rel="noopener" data-doc-id="${docId}">Download source</a>` : '';
                const match = data.hits.find(h => h.chunk_id === r.chunk_id);
                const txt = match ? highlight(match.content || '', query) : '';
                return `<div class="hit"><details><summary>[${idx+1}] ${escapeHtml(fn)}${ft ? ` (${escapeHtml(ft)})` : ''} ${link}</summary><div class="hit-content">${txt}</div></details></div>`;
              }).join('');
              refsEl.innerHTML = items;
            } else {
              refsEl.style.display = 'none';
              if (refsLabel) refsLabel.style.display = 'none';
              refsEl.innerHTML = '';
            }
          }
        }
        renderResults(data.hits, query);
      } catch (e) {
        if (e.name !== 'AbortError') {
          showToast('Search failed');
          console.error(e);
        }
      } finally {
        if (currentSearchController === ctrl) currentSearchController = null;
        loading.hidden = true;
        btn.disabled = false;
      }
    }

    document.addEventListener('keydown', (e) => {
      const q = document.getElementById('searchInput');
      if (e.key === 'Enter' && document.activeElement === q) {
        e.preventDefault();
        triggerUnifiedSearch();
      } else if (e.key === 'Escape') {
        searchInputEl.value = '';
        document.getElementById('answer').textContent = '';
        document.getElementById('answerRow').hidden = true;
        const res = document.getElementById('results');
        res.innerHTML = '';
        document.getElementById('resultsRow').hidden = true;
      }
    });

    // Unified search mode handling
    const searchInputEl = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const textModeBtn = document.getElementById('searchModeText');
    const imageModeBtn = document.getElementById('searchModeImage');
    const textSettingsPane = document.getElementById('textSettings');
    const imageSettingsPane = document.getElementById('imageSettings');
    const imageResultsSection = document.getElementById('imageResultsSection');
    const imageTagsEl = document.getElementById('imageTags');
    const imageTopKEl = document.getElementById('imageTopK');
    const imageThumbSizeEl = document.getElementById('imageThumbSize');
    const imageFileEl = document.getElementById('imageFile');
    const imageResultsGrid = document.getElementById('imageResultsGrid');
    const imageEmptyState = document.getElementById('imageResultsEmpty');
    const imageLoading = document.getElementById('imageSearchLoading');
    const unifiedModeState = {
      active: 'text',
      imageHasResults: false,
    };

    function setSearchMode(nextMode) {
      if (nextMode === unifiedModeState.active) return;
      unifiedModeState.active = nextMode;
      if (nextMode === 'text') {
        textModeBtn.classList.add('active');
        textModeBtn.setAttribute('aria-selected', 'true');
        imageModeBtn.classList.remove('active');
        imageModeBtn.setAttribute('aria-selected', 'false');
        searchInputEl.placeholder = 'Search documents‚Ä¶';
        textSettingsPane.hidden = false;
        imageSettingsPane.hidden = true;
        searchBtn.textContent = 'Search';
        if (imageResultsSection) imageResultsSection.hidden = true;
      } else {
        imageModeBtn.classList.add('active');
        imageModeBtn.setAttribute('aria-selected', 'true');
        textModeBtn.classList.remove('active');
        textModeBtn.setAttribute('aria-selected', 'false');
        searchInputEl.placeholder = "Describe the image you're looking for‚Ä¶";
        textSettingsPane.hidden = true;
        imageSettingsPane.hidden = false;
        searchBtn.textContent = 'Find images';
        if (imageResultsSection) imageResultsSection.hidden = false;
        if (!unifiedModeState.imageHasResults) resetImageResults();
      }
    }

    textModeBtn.addEventListener('click', () => setSearchMode('text'));
    imageModeBtn.addEventListener('click', () => setSearchMode('image'));

    function triggerUnifiedSearch() {
      if (unifiedModeState.active === 'image') {
        doImageSearch();
      } else {
        doSearch();
      }
    }

    searchBtn.addEventListener('click', () => triggerUnifiedSearch());

    searchInputEl.addEventListener('input', () => {
      const auto = document.getElementById('autoSearch')?.checked ?? false;
      const delay = parseInt(document.getElementById('debounceMs')?.value || '400', 10);
      if (auto && unifiedModeState.active === 'text') {
        clearTimeout(searchTimer);
        searchTimer = setTimeout(() => doSearch().catch(console.error), delay);
      }
    });

    function resetImageResults() {
      imageResultsGrid.innerHTML = '';
      unifiedModeState.imageHasResults = false;
      if (imageEmptyState) imageEmptyState.hidden = false;
      if (imageResultsSection) imageResultsSection.hidden = unifiedModeState.active !== 'image';
    }

    function renderImageResults(results) {
      imageResultsGrid.innerHTML = '';
      if (!Array.isArray(results) || !results.length) {
        unifiedModeState.imageHasResults = false;
        if (imageEmptyState) imageEmptyState.hidden = false;
        return;
      }
      unifiedModeState.imageHasResults = true;
      if (imageEmptyState) imageEmptyState.hidden = true;
      if (imageResultsSection) imageResultsSection.hidden = false;
      const size = imageThumbSizeEl.value || 'medium';
      const cards = results.map((item) => {
        const rawThumb = item.thumbnail_url || item.thumbnail_object_url || item.thumbnail_path || item.file_path || '';
        const thumb = rawThumb ? escapeHtml(rawThumb) : '';
        const caption = escapeHtml(item.caption || 'Untitled image');
        const tags = Array.isArray(item.tags) ? item.tags : [];
        const tagBadges = tags.map(t => `<span class="badge badge-soft">${escapeHtml(t)}</span>`).join('');
        const meta = [];
        if (item.score != null) {
          const score = (item.score ?? '').toFixed ? item.score.toFixed(3) : item.score;
          meta.push(`<span class="badge">score ${score}</span>`);
        }
        if (item.rank != null) meta.push(`<span class="badge">#${item.rank}</span>`);
        if (item.object_url || item.thumbnail_object_url) meta.push('<span class="badge badge-remote">Remote</span>');
        const docId = item.doc_id != null ? Number(item.doc_id) : null;
        const primaryHref = item.file_url || (docId != null ? `/api/doc-download?doc_id=${encodeURIComponent(docId)}` : '');
        const remoteHref = item.object_url ? escapeHtml(item.object_url) : null;
        const sourceLink = primaryHref ? `<a class="ghost" href="${escapeHtml(primaryHref)}" target="_blank" rel="noopener">Open document</a>` : '';
        const remoteLink = remoteHref ? `<a class="ghost" href="${remoteHref}" target="_blank" rel="noopener">Object copy</a>` : '';
        return `
          <div class="image-card ${size}">
            <div class="image-card-thumb">${thumb ? `<img src="${thumb}" alt="result ${item.rank || ''}" loading="lazy" />` : '<div class="thumb-placeholder">No preview</div>'}</div>
            <div class="image-card-body">
              <div class="image-card-meta">${meta.join('')}</div>
              <p class="image-card-caption">${caption}</p>
              <div class="image-card-tags">${tagBadges || '<span class="muted">No tags</span>'}</div>
              <div class="image-card-actions">${sourceLink}${remoteLink}</div>
            </div>
          </div>`;
      }).join('');
      imageResultsGrid.innerHTML = cards;
    }

    async function doImageSearch() {
      if (!state.user) { showToast('Login required'); return; }
      const query = (searchInputEl.value || '').trim();
      const tagsRaw = imageTagsEl.value || '';
      const topK = parseInt(imageTopKEl.value || '12', 10);
      const file = imageFileEl.files && imageFileEl.files[0] ? imageFileEl.files[0] : null;

      if (!query && !tagsRaw && !file) {
        showToast('Enter a query, tags, or choose a reference image');
        return;
      }

      if (state.imageSearchAbort) {
        state.imageSearchAbort.abort();
        state.imageSearchAbort = null;
      }

      const controller = new AbortController();
      state.imageSearchAbort = controller;
      imageLoading.hidden = false;
      imageResultsGrid.innerHTML = '';
      if (imageResultsSection) imageResultsSection.hidden = false;
      if (imageEmptyState) imageEmptyState.hidden = true;

      try {
        const tags = tagsRaw.split(',').map(t => t.trim()).filter(Boolean);
        const payload = { query, tags, top_k: topK, space_id: state.spaceId };
        let body;
        let headers;
        if (file) {
          body = new FormData();
          Object.entries(payload).forEach(([k, v]) => {
            if (Array.isArray(v)) {
              body.append(k, JSON.stringify(v));
            } else if (v != null) {
              body.append(k, v);
            }
          });
          body.append('reference', file);
        } else {
          body = payload;
          headers = { 'Content-Type': 'application/json' };
        }
        const res = await api('/api/image-search', { method: 'POST', body, headers, signal: controller.signal });
        renderImageResults(res.results || []);
        showToast(`Found ${res.count || 0} images`);
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error(e);
          showToast('Image search failed');
        }
      } finally {
        imageLoading.hidden = true;
        if (state.imageSearchAbort === controller) state.imageSearchAbort = null;
      }
    }

    function clearImageSearch() {
      searchInputEl.value = '';
      imageTagsEl.value = '';
      imageTopKEl.value = '12';
      if (imageFileEl) imageFileEl.value = '';
      resetImageResults();
    }

    const imageClearBtn = document.getElementById('imageClearBtn');
    if (imageClearBtn) imageClearBtn.addEventListener('click', () => clearImageSearch());

    // Deep Research UI
    let dr = { open: false, conversationId: null };
    function drStorageKey(spaceId) { return `dr:space:${spaceId || '_'}`; }

    function openDr() {
      const m = document.getElementById('drModal');
      const b = document.getElementById('drBackdrop');
      if (b) b.hidden = false;
      if (m) m.hidden = false;
      dr.open = true;
      document.getElementById('drMessage')?.focus();
    }
    function closeDr() {
      const m = document.getElementById('drModal');
      const b = document.getElementById('drBackdrop');
      if (b) b.hidden = true;
      if (m) m.hidden = true;
      dr.open = false;
    }
    async function ensureDrConversation() {
      if (dr.conversationId) return dr.conversationId;
      // Try to resume previous conversation per-space
      const key = drStorageKey(state.spaceId);
      try {
        const saved = localStorage.getItem(key);
        if (saved) { dr.conversationId = saved; return saved; }
      } catch {}
      const payload = { space_id: state.spaceId };
      const r = await api('/api/deep-research/start', { method: 'POST', body: payload });
      dr.conversationId = r.conversation_id;
      try { localStorage.setItem(key, dr.conversationId); } catch {}
      return dr.conversationId;
    }
    async function resetDr() {
      try {
        const key = drStorageKey(state.spaceId);
        try { localStorage.removeItem(key); } catch {}
        const payload = { space_id: state.spaceId };
        const r = await api('/api/deep-research/start', { method: 'POST', body: payload });
        dr.conversationId = r.conversation_id;
        try { localStorage.setItem(key, dr.conversationId); } catch {}
        const chat = document.getElementById('drChat');
        if (chat) chat.innerHTML = '';
        showToast('Started a new Deep Research conversation');
      } catch (e) {
        showToast('Failed to reset conversation');
      }
    }
    function renderDrMetadata(meta) {
      if (!meta) return '';
      const parts = [];
      if (typeof meta.confidence === 'number') {
        parts.push(`<span class="badge">Confidence ${(meta.confidence * 100).toFixed(0)}%</span>`);
      }
      if (typeof meta.elapsed_seconds === 'number') {
        parts.push(`<span class="badge badge-soft">${meta.elapsed_seconds}s</span>`);
      }
      if (meta.web_attempted) {
        parts.push('<span class="badge badge-web">Web search triggered</span>');
      } else {
        parts.push('<span class="badge badge-local">Local context only</span>');
      }
      return parts.join('');
    }

    function normalizeUrl(raw) {
      if (!raw || typeof raw !== 'string') return '#';
      const trimmed = raw.trim();
      if (!trimmed) return '#';
      if (/^https?:\/\//i.test(trimmed)) return trimmed;
      if (/^[a-z]+:\/\//i.test(trimmed)) return trimmed;
      return `https://${trimmed.replace(/^\/+/, '')}`;
    }

    function renderDrReferences(refs) {
      if (!Array.isArray(refs) || !refs.length) return '';
      const localRefs = refs.filter(r => r.source === 'local');
      const webRefs = refs.filter(r => r.source === 'web');

      const buildChunkCard = (ref, idx, type) => {
        const num = ref.rank ?? (idx + 1);
        const title = escapeHtml(ref.title || (type === 'local' ? basename(ref.source_path || '') || `Document ${ref.document_id ?? idx + 1}` : `Web result ${idx + 1}`));
        const chunkLabel = typeof ref.chunk_index === 'number' ? `Chunk #${ref.chunk_index}` : null;
        const subtitleBits = [];
        if (chunkLabel) subtitleBits.push(chunkLabel);
        if (type === 'local' && ref.source_path) subtitleBits.push(basename(ref.source_path));
        if (type === 'web' && ref.url) subtitleBits.push(ref.url.replace(/^https?:\/\//, ''));
        const subtitle = subtitleBits.join(' ‚Ä¢ ');
        const textField = type === 'local' ? (ref.excerpt || ref.snippet || ref.text || '') : (ref.snippet || ref.excerpt || '');
        const trimmed = textField.trim();
        const display = trimmed ? escapeHtml(trimmed.length > 320 ? `${trimmed.slice(0, 320)}‚Ä¶` : trimmed) : '<span class="muted">No excerpt available.</span>';
        const downloadHref = type === 'local' && ref.document_id ? `/api/doc-download?doc_id=${encodeURIComponent(ref.document_id)}` : '';
        const badge = type === 'local' ? '<span class="pill-badge">Local</span>' : '<span class="pill-badge pill-web">Web</span>';
        const action = type === 'local'
          ? (downloadHref ? `<a class="ghost" href="${escapeHtml(downloadHref)}" target="_blank" rel="noopener">Open document</a>` : '')
          : `<a class="ghost" href="${escapeHtml(normalizeUrl(ref.url))}" target="_blank" rel="noopener">Open link</a>`;
        return `
          <details class="dr-source-card" data-source="${type}">
            <summary>
              <div class="dr-source-chip">${badge}<span class="rank">#${num}</span></div>
              <div class="dr-source-summary">
                <div class="title">${title}</div>
                ${subtitle ? `<div class="sub">${escapeHtml(subtitle)}</div>` : ''}
              </div>
              <span class="chevron">‚ñ∏</span>
            </summary>
            <div class="dr-source-body">
              <div class="snippet">${display}</div>
              <div class="actions">${action || ''}</div>
            </div>
          </details>`;
      };

      const buildDeck = (items, typeLabel, type) => {
        if (!items.length) return '';
        return `
          <details class="dr-source-deck" data-type="${type}" ${type === 'local' ? '' : ''}>
            <summary>
              <div class="deck-header">
                <span class="deck-title">${typeLabel}</span>
                <span class="deck-count">${items.length} item${items.length === 1 ? '' : 's'}</span>
                <span class="chevron">‚ñ∏</span>
              </div>
            </summary>
            <div class="deck-body">
              ${items.map((ref, idx) => buildChunkCard(ref, idx, type)).join('')}
            </div>
          </details>`;
      };

      const decks = [
        buildDeck(localRefs, 'Knowledge Base Sources', 'local'),
        buildDeck(webRefs, 'Web Sources', 'web'),
      ].filter(Boolean).join('');

      return `
        <details class="dr-sources">
          <summary>
            <span class="pill-badge pill-source">Sources</span>
            <span class="muted">Tap to expand local & web evidence</span>
            <span class="chevron">‚ñ∏</span>
          </summary>
          <div class="dr-sources-body">
            ${decks || '<div class="muted">No supporting evidence returned.</div>'}
          </div>
        </details>`;
    }

    function pushMsg(role, text, meta) {
      const chat = document.getElementById('drChat');
      const div = document.createElement('div');
      div.className = 'dr-msg ' + (role === 'user' ? 'me' : 'ai');
      let content;
      if (role === 'assistant') {
        const refs = renderDrReferences(meta?.references);
        const badges = renderDrMetadata(meta);
        content = `${badges ? `<div class="dr-meta">${badges}</div>` : ''}${renderLLMText(text)}${refs}`;
      } else {
        content = `<p>${escapeHtml(text)}</p>`;
      }
      div.innerHTML = `<div class="bubble">${content}</div>`;
      chat.appendChild(div);
      chat.scrollTop = chat.scrollHeight;
    }
    async function sendDr() {
      const inp = document.getElementById('drMessage');
      const txt = (inp.value || '').trim();
      if (!txt) return;
      inp.value = '';
      pushMsg('user', txt);
      // Show thinking indicator (animated dots only, no bubble)
      const chat = document.getElementById('drChat');
      const th = document.createElement('div');
      th.className = 'dr-thinking-card';
      th.innerHTML = `<div class="dr-thinking-spinner"></div><div>Researching‚Ä¶</div>`;
      chat.appendChild(th);
      chat.scrollTop = chat.scrollHeight;
      try {
        const cid = await ensureDrConversation();
        const provider = document.getElementById('provider')?.value || undefined;
        const body = { conversation_id: cid, message: txt, space_id: state.spaceId, llm_provider: provider };
        const r = await api('/api/deep-research/ask', { method: 'POST', body });
        const ans = (r && r.answer) ? String(r.answer) : '(no answer)';
        const meta = {
          confidence: typeof r.confidence === 'number' ? r.confidence : undefined,
          elapsed_seconds: r.elapsed_seconds,
          web_attempted: r.web_attempted,
          references: Array.isArray(r.references) ? r.references : [],
        };
        // Replace thinking bubble with answer
        if (th && th.parentElement) th.parentElement.removeChild(th);
        pushMsg('assistant', ans, meta);
      } catch (e) {
        if (th && th.parentElement) th.parentElement.removeChild(th);
        pushMsg('assistant', 'Sorry, something went wrong.');
      }
    }

    document.getElementById('drBtn')?.addEventListener('click', async () => { try { await ensureDrConversation(); } catch {} openDr(); });
    document.getElementById('drClose')?.addEventListener('click', () => closeDr());
    document.getElementById('drReset')?.addEventListener('click', async () => { await resetDr(); });
    document.getElementById('drSend')?.addEventListener('click', () => sendDr());
    document.getElementById('drMessage')?.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendDr(); } });
    document.getElementById('drBackdrop')?.addEventListener('click', () => closeDr());

    document.getElementById('mode').addEventListener('change', () => {
      if (document.getElementById('autoSearch').checked && unifiedModeState.active === 'text') doSearch();
    });
    document.getElementById('topk').addEventListener('change', () => {
      if (document.getElementById('autoSearch').checked && unifiedModeState.active === 'text') doSearch();
    });

    document.getElementById('settingsBtn').addEventListener('click', () => {
      const p = document.getElementById('settingsPanel');
      const b = document.getElementById('settingsBtn');
      const nowHidden = !p.hidden;
      p.hidden = nowHidden;
      b.setAttribute('aria-expanded', String(!nowHidden));
    });

    async function loadProviders() {
      try {
        const p = await api('/api/providers');
        const sel = document.getElementById('provider');
        if (sel && p && Array.isArray(p.supported)) {
          const keep = sel.value;
          sel.innerHTML = '';
          const opt0 = document.createElement('option'); opt0.value = ''; opt0.textContent = 'Default'; sel.appendChild(opt0);
          for (const v of p.supported) { const o = document.createElement('option'); o.value = v; o.textContent = v.toUpperCase(); sel.appendChild(o); }
          const preferred = 'bedrock';
          sel.value = keep || (p.supported.includes(preferred) ? preferred : '');
        }
      } catch {}
    }

    async function loadSearchConfig() {
      try {
        const cfg = await api('/api/search-config');
        const be = document.getElementById('cfgBackend'); if (be) be.textContent = cfg.backend || '-';
        const t = document.getElementById('cfgTopK'); if (t) t.value = cfg.default_top_k != null ? String(cfg.default_top_k) : '';
        const tk = document.getElementById('topk'); if (tk && cfg.default_top_k != null) tk.value = String(cfg.default_top_k);
        const pgRow = document.getElementById('cfgPgvectorRow');
        const osRow = document.getElementById('cfgNumCandRow');
        const pgv = document.getElementById('cfgProbes');
        const ncd = document.getElementById('cfgNumCand');
        if (cfg.backend === 'pgvector') {
          if (pgRow) pgRow.hidden = false; if (osRow) osRow.hidden = true;
          if (pgv) pgv.value = cfg.pgvector_probes != null ? String(cfg.pgvector_probes) : '';
        } else {
          if (pgRow) pgRow.hidden = true;
          const engine = (cfg.opensearch?.engine || 'lucene').toLowerCase();
          if (osRow) osRow.hidden = engine === 'lucene';
          if (ncd) ncd.value = cfg.opensearch?.num_candidates != null ? String(cfg.opensearch.num_candidates) : '';
        }
      } catch (e) {
        // ignore (likely 401 if not logged-in yet)
      }
    }

    async function saveSearchConfig() {
      try {
        const t = document.getElementById('cfgTopK');
        const pgv = document.getElementById('cfgProbes');
        const ncd = document.getElementById('cfgNumCand');
        const body = {};
        if (t && t.value !== '') body.default_top_k = parseInt(t.value, 10);
        if (pgv && !pgv.parentElement.hidden) body.pgvector_probes = pgv.value === '' ? null : parseInt(pgv.value, 10);
        if (ncd && !ncd.parentElement.hidden) body.os_num_candidates = ncd.value === '' ? null : parseInt(ncd.value, 10);
        const resp = await api('/api/search-config', { method: 'POST', body });
        if (resp && resp.ok) { showToast('Saved'); await loadSearchConfig(); }
      } catch (e) {
        showToast('Save failed');
      }
    }

    const loadCfgBtn = document.getElementById('loadCfgBtn');
    if (loadCfgBtn) loadCfgBtn.addEventListener('click', () => loadSearchConfig());
    const saveCfgBtn = document.getElementById('saveCfgBtn');
    if (saveCfgBtn) saveCfgBtn.addEventListener('click', () => saveSearchConfig());

    // Knowledge Base logic
    async function fetchDocUrl(docId) {
      try {
        const r = await api(`/api/doc-url?doc_id=${encodeURIComponent(docId)}`);
        if (r && r.url) return r.url;
      } catch (e) {}
      return null;
    }

    let kbOrder = 'desc';

    async function loadKB() {
      try {
        const qsParts = [];
        if (state.spaceId) qsParts.push(`space_id=${encodeURIComponent(state.spaceId)}`);
        if (kbOrder) qsParts.push(`order=${encodeURIComponent(kbOrder)}`);
        const qs = qsParts.length ? `?${qsParts.join('&')}` : '';
        const data = await api(`/api/kb${qs}`);
        const list = document.getElementById('kbList');
        const sec = document.getElementById('kbSection');
        list.innerHTML = '';
        if (Array.isArray(data.documents) && data.documents.length) {
          data.documents.forEach((doc) => {
            const div = document.createElement('div');
            div.className = 'kb-doc-item';
            const docTitle = formatDocTitle(doc);
            const link = `<a href="#" data-doc-id="${doc.id}">${escapeHtml(docTitle)}</a>`;
            const metaChips = [];
            if (doc.source_type) metaChips.push(`<span class="badge badge-soft">${escapeHtml(doc.source_type)}</span>`);
            if (typeof doc.chunk_count === 'number') metaChips.push(`<span class="badge badge-soft">${doc.chunk_count} chunks</span>`);
            const created = formatDateLabel(doc.created_at);
            if (created) metaChips.push(`<span class="badge badge-soft">${escapeHtml(created)}</span>`);
            if (doc.metadata && doc.metadata.object_url) metaChips.push('<span class="badge badge-remote">Remote</span>');
            const metaHtml = metaChips.length ? `<div class="kb-doc-meta">${metaChips.join('')}</div>` : '';

            const docImages = Array.isArray(doc.images) ? doc.images : [];
            const downloadHref = doc.id ? `/api/doc-download?doc_id=${doc.id}` : '';
            const previewSrc = docImages.length ? (docImages[0].thumbnail_url || docImages[0].thumbnail_object_url || docImages[0].thumbnail_path || docImages[0].file_path || '') : (doc.thumbnail_preview_url || '');
            const previewBlock = previewSrc ? `<div class="kb-doc-preview"><img src="${escapeHtml(previewSrc)}" alt="Preview for ${escapeHtml(docTitle)}" loading="lazy" /></div>` : '';

            const infoLines = [];
            if (created) infoLines.push(`<li><strong>Created:</strong> ${escapeHtml(created)}</li>`);
            if (typeof doc.chunk_count === 'number') infoLines.push(`<li><strong>Chunks:</strong> ${doc.chunk_count}</li>`);
            if (doc.metadata && doc.metadata.summary) infoLines.push(`<li><strong>Summary:</strong> ${escapeHtml(doc.metadata.summary)}</li>`);
            if (Array.isArray(doc.metadata?.image_tags) && doc.metadata.image_tags.length) {
              infoLines.push(`<li><strong>Tags:</strong> ${doc.metadata.image_tags.map(t => escapeHtml(String(t))).join(', ')}</li>`);
            }
            if (doc.metadata && doc.metadata.image_caption && !doc.metadata?.summary) {
              infoLines.push(`<li><strong>Caption:</strong> ${escapeHtml(doc.metadata.image_caption)}</li>`);
            }
            const infoHtml = infoLines.length ? `<ul class="kb-meta-list">${infoLines.join('')}</ul>` : '<p class="muted">No additional metadata yet.</p>';

            const gallery = docImages.map((img) => {
              const thumbSrc = img.thumbnail_url || img.thumbnail_object_url || img.thumbnail_path || img.file_path || '';
              const thumb = thumbSrc ? escapeHtml(thumbSrc) : '';
              const caption = escapeHtml(img.caption || 'No caption');
              const tags = Array.isArray(img.tags) ? img.tags.map(t => `<span class="badge badge-soft">${escapeHtml(t)}</span>`).join('') : '';
              const remote = (img.object_url || img.thumbnail_object_url) ? '<span class="badge badge-remote">Remote</span>' : '';
              const fileUrl = img.file_url || (doc.id ? `/api/doc-download?doc_id=${doc.id}` : '');
              const downloadLink = fileUrl ? `<a class="ghost" href="${escapeHtml(fileUrl)}" target="_blank" rel="noopener">Open document</a>` : '';
              const objectLink = img.object_url ? `<a class="ghost" href="${escapeHtml(img.object_url)}" target="_blank" rel="noopener">Object copy</a>` : '';
              return `
                <div class="kb-image-card">
                  <div class="kb-image-thumb">${thumb ? `<img src="${thumb}" alt="thumbnail for doc ${doc.id}" loading="lazy" />` : '<div class="thumb-placeholder">No preview</div>'}</div>
                  <div class="kb-image-body">
                    <div class="kb-image-caption">${caption} ${remote}</div>
                    <div class="kb-image-tags">${tags || '<span class="muted">No tags</span>'}</div>
                    <div class="kb-image-actions">${downloadLink}${objectLink}</div>
                  </div>
                </div>`;
            }).join('');

            const attachments = docImages.length ? `<details class="kb-attachments"><summary>Images (${docImages.length})</summary><div class="kb-image-grid">${gallery}</div></details>` : '';

            const downloadAction = downloadHref ? `<a class="ghost" href="${escapeHtml(downloadHref)}" target="_blank" rel="noopener">Download</a>` : '';

            div.innerHTML = `
              <div class="kb-doc-card">
                <div class="kb-doc-head">
                  <label class="kb-doc-select">
                    <input type="checkbox" class="kbSel" data-doc-id="${doc.id}" aria-label="Select document" />
                    <span>${link}</span>
                  </label>
                  <div class="kb-doc-actions">
                    ${downloadAction}
                    <button class="ghost" data-delete-doc-id="${doc.id}">Delete</button>
                  </div>
                </div>
                ${metaHtml}
                <div class="kb-doc-body">
                  ${previewBlock}
                  <div class="kb-doc-details">
                    ${infoHtml}
                    ${attachments}
                  </div>
                </div>
              </div>
            `;
            list.appendChild(div);
          });
        } else {
          list.textContent = 'No documents yet.';
        }
        sec.hidden = false;
        window.scrollTo({ top: sec.offsetTop - 16, behavior: 'smooth' });
      } catch (e) {
        console.error(e);
        showToast('Failed to load knowledge base');
      }
    }

    document.addEventListener('click', async (e) => {
      const a = e.target.closest('a[data-doc-id]');
      if (a) {
        e.preventDefault();
        const docId = a.getAttribute('data-doc-id');
        window.open(`/api/doc-download?doc_id=${encodeURIComponent(docId)}`, '_blank');
      }
    });

    const kbRefreshBtn = document.getElementById('kbRefreshBtn');
    if (kbRefreshBtn) kbRefreshBtn.addEventListener('click', () => loadKB());

    const kbSortBtn = document.getElementById('kbSortBtn');
    if (kbSortBtn) kbSortBtn.addEventListener('click', () => {
      kbOrder = (kbOrder === 'desc') ? 'asc' : 'desc';
      kbSortBtn.textContent = kbOrder === 'desc' ? 'Latest first' : 'Oldest first';
      loadKB();
    });

    // KB delete single
    document.addEventListener('click', async (e) => {
      const btn = e.target.closest('button[data-delete-doc-id]');
      if (btn) {
        e.preventDefault();
        const id = btn.getAttribute('data-delete-doc-id');
        const ok = confirm('Are you sure you want to delete this file?');
        if (!ok) return;
        try {
          const res = await fetch(`/api/admin/documents/${encodeURIComponent(id)}`, { method: 'DELETE' });
          if (res.ok) { showToast('Deleted'); await loadKB(); } else { showToast('Delete failed'); }
        } catch { showToast('Delete failed'); }
      }
    });

    // KB bulk select/delete
    const kbSelectAll = document.getElementById('kbSelectAll');
    if (kbSelectAll) kbSelectAll.addEventListener('change', () => {
      const boxes = document.querySelectorAll('input.kbSel');
      boxes.forEach(b => { b.checked = kbSelectAll.checked; });
    });
    const kbDeleteSelectedBtn = document.getElementById('kbDeleteSelectedBtn');
    if (kbDeleteSelectedBtn) kbDeleteSelectedBtn.addEventListener('click', async () => {
      const boxes = Array.from(document.querySelectorAll('input.kbSel:checked'));
      if (!boxes.length) { showToast('No selection'); return; }
      const ok = confirm(`Are you sure you want to delete ${boxes.length} file(s)?`);
      if (!ok) return;
      for (const b of boxes) {
        const id = b.getAttribute('data-doc-id');
        try { await fetch(`/api/admin/documents/${encodeURIComponent(id)}`, { method: 'DELETE' }); } catch {}
      }
      showToast('Delete requested');
      await loadKB();
    });

    // Drag-and-drop support
    const dropzone = document.getElementById('dropzone');
    const dzStatus = document.getElementById('dzStatus');
    let droppedFiles = [];

    let ALLOWED_EXTS = new Set([".pdf",".txt",".csv",".md",".json",".html",".htm",".docx",".pptx",".xlsx",".png",".jpg",".jpeg",".tif",".tiff",".bmp",".gif"]);
    let SUPPORTED_TYPES_TXT = 'PDF, DOCX, PPTX, XLSX, TXT, HTML, CSV, MD, JSON, PNG, JPG, JPEG, TIFF, BMP, GIF';
    let MAX_FILES = 100;
    let MAX_BYTES = 50 * 1024 * 1024; // 50MB

    async function loadUploadConfig() {
      try {
        const cfg = await api('/api/upload-config');
        if (cfg && typeof cfg === 'object') {
          if (Array.isArray(cfg.allowed_extensions) && cfg.allowed_extensions.length) {
            ALLOWED_EXTS = new Set(cfg.allowed_extensions.map(e => String(e).toLowerCase()));
            const list = Array.from(ALLOWED_EXTS).map(e => e.replace(/^\./, '').toUpperCase());
            SUPPORTED_TYPES_TXT = list.join(', ');
          }
          if (cfg.max_upload_files != null) {
            MAX_FILES = parseInt(cfg.max_upload_files, 10) || MAX_FILES;
          }
          if (cfg.max_upload_size_mb != null) {
            MAX_BYTES = (parseInt(cfg.max_upload_size_mb, 10) || 50) * 1024 * 1024;
          }
          const hint = document.getElementById('dzHint');
          if (hint) hint.textContent = `Maximum ${Math.round(MAX_BYTES/1024/1024)}MB per file ‚Ä¢ Maximum ${MAX_FILES} files per batch`;

          const info = document.getElementById('uploadStorageInfo');
          if (info) {
            const lines = [];
            const backend = (cfg.storage_backend || 'local').toString().toUpperCase();
            lines.push(`Storage backend: ${backend}`);
            if (cfg.enable_image_storage === false) {
              lines.push('Image ingestion disabled (vision embeddings off).');
            }
            if (cfg.oci) {
              const oci = cfg.oci;
              if (oci.upload_enabled) {
                if (oci.ready === false) {
                  lines.push(`‚ö†Ô∏è OCI uploads blocked: ${oci.detail || 'missing bucket or credentials'}`);
                } else if (oci.ready === true) {
                  lines.push(`OCI bucket ${(oci.bucket || '').toString()} ready for mirroring.`);
                } else {
                  lines.push('Validating OCI configuration‚Ä¶');
                }
              } else {
                lines.push('OCI mirroring disabled.');
              }
            }
            info.innerHTML = lines.map(line => `<div>${escapeHtml(line)}</div>`).join('');
            info.hidden = lines.length === 0;
          }
        }
      } catch (e) {
        // ignore, keep defaults
      }
    }

    function addFilesToList(fileList, opts = { isFolder: false }) {
      const added = [];
      const skipped = [];
      let skippedType = 0;
      let skippedSize = 0;
      for (const f of fileList) {
        if (droppedFiles.length + added.length >= MAX_FILES) { skipped.push(`${f.name} (limit reached)`); continue; }
        const ext = ('.' + (f.name.split('.').pop() || '')).toLowerCase();
        if (!ALLOWED_EXTS.has(ext)) { skipped.push(`${f.name} (type)`); skippedType++; continue; }
        if (f.size > MAX_BYTES) { skipped.push(`${f.name} (size)`); skippedSize++; continue; }
        added.push(f);
      }
      droppedFiles.push(...added);
      if (dzStatus) dzStatus.textContent = droppedFiles.length ? `${droppedFiles.length} file(s) ready` : 'Drop files here or use the file chooser below';
      if (opts.isFolder && (skippedType > 0 || (fileList.length + (droppedFiles.length - added.length)) > MAX_FILES)) {
        showToast(`Folder contains unsupported types or too many files. Please upload a folder with 100 files or less and only supported types: ${SUPPORTED_TYPES_TXT}.`);
      } else if (skipped.length) {
        showToast(`Some files skipped: ${skipped.slice(0,3).join(', ')}${skipped.length>3?'‚Ä¶':''}`);
      } else {
        showToast(`${droppedFiles.length} file(s) ready`);
      }
    }

    async function traverseEntry(entry) {
      return new Promise((resolve) => {
        if (entry.isFile) {
          entry.file(file => resolve([file]));
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          const out = [];
          const read = () => reader.readEntries(async entries => {
            if (!entries.length) return resolve(out);
            for (const e of entries) {
              const nested = await traverseEntry(e);
              out.push(...nested);
            }
            read();
          });
          read();
        } else {
          resolve([]);
        }
      });
    }

    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });
    dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.classList.remove('dragover');
      const items = e.dataTransfer.items;
      let isFolder = false;
      if (items && items.length && items[0].webkitGetAsEntry) {
        let all = [];
        for (const it of items) {
          const entry = it.webkitGetAsEntry();
          if (entry) {
            if (entry.isDirectory) isFolder = true;
            const files = await traverseEntry(entry);
            all.push(...files);
          }
        }
        addFilesToList(all, { isFolder });
      } else {
        addFilesToList(e.dataTransfer.files, { isFolder: false });
      }
    });

    const filesInputEl = document.getElementById('files');
    if (filesInputEl) {
      filesInputEl.addEventListener('change', () => {
        const count = filesInputEl.files ? filesInputEl.files.length : 0;
        const badge = document.getElementById('fileSelectionText');
        if (badge) badge.textContent = count ? `${count} file(s) selected.` : 'No files selected.';
        if (dzStatus) dzStatus.textContent = count ? `${count} file(s) selected` : 'Drop files here or use the file chooser below';
      });
    }

    // Upload with per-file progress and space_id
    const clearBtn = document.getElementById('clearUploadBtn');
    if (clearBtn) clearBtn.addEventListener('click', () => {
      try {
        const files = document.getElementById('files');
        const status = document.getElementById('uploadStatus');
        const list = document.getElementById('uploadList');
        const listRow = document.getElementById('uploadListRow');
        const statusRow = document.getElementById('uploadStatusRow');
        const badge = document.getElementById('fileSelectionText');
        if (files) files.value = '';
        if (status) status.textContent = '';
        if (list) list.innerHTML = '';
        if (listRow) listRow.hidden = true;
        if (statusRow) statusRow.hidden = true;
        droppedFiles = [];
        if (dzStatus) dzStatus.textContent = 'Drop files here or use the file chooser below';
        if (badge) badge.textContent = 'No files selected.';
        showToast('Cleared');
      } catch {}
    });

    document.getElementById('uploadBtn').addEventListener('click', async () => {
      if (!state.user) { showToast('Login required'); return; }
      const filesInput = document.getElementById('files');
      const status = document.getElementById('uploadStatus');
      const statusRow = document.getElementById('uploadStatusRow');
      const loading = document.getElementById('uploadLoading');
      const list = document.getElementById('uploadList');
      const listRow = document.getElementById('uploadListRow');
      status.textContent = '';

      const selA = filesInput?.files ? Array.from(filesInput.files) : [];
      let allFiles = [...selA, ...droppedFiles];
      if (!allFiles.length) { showToast('No files selected'); return; }
      // Filter client-side as well
      const filtered = [];
      for (const f of allFiles) {
        const ext = ('.' + (f.name.split('.').pop() || '')).toLowerCase();
        if (!ALLOWED_EXTS.has(ext)) continue;
        if (f.size > MAX_BYTES) continue;
        filtered.push(f);
        if (filtered.length >= MAX_FILES) break;
      }
      allFiles = filtered;
      if (!allFiles.length) { showToast('No valid files to upload'); return; }

      list.innerHTML = '';
      listRow.hidden = false;
      statusRow.hidden = false;
      const entries = new Map();
      for (const f of allFiles) {
        const item = document.createElement('div');
        item.className = 'progress-item';
        item.innerHTML = `
          <div class="progress-row"><span>${escapeHtml(f.webkitRelativePath || f.name)}</span><span class="pct">0%</span></div>
          <div class="progress"><div class="progress-bar"></div></div>
        `;
        list.appendChild(item);
        entries.set(f, item);
      }

      loading.hidden = false;

      const maxRetries = 3;
      const backoff = (attempt) => Math.min(2000, 300 * Math.pow(2, attempt - 1));

      function uploadOne(file, attempt = 1) {
        return new Promise((resolve) => {
          const item = entries.get(file);
          const bar = item.querySelector('.progress-bar');
          const pctLabel = item.querySelector('.pct');
          const xhr = new XMLHttpRequest();
          xhr.open('POST', '/api/upload');

          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const pct = Math.round((e.loaded / e.total) * 100);
              bar.style.width = pct + '%';
              pctLabel.textContent = pct + '%';
            } else {
              bar.style.width = '50%';
              pctLabel.textContent = '‚Ä¶';
            }
          };
          xhr.upload.onload = () => { pctLabel.textContent = 'processing‚Ä¶'; };

          xhr.onerror = () => {
            if (attempt < maxRetries) {
              const delay = backoff(attempt);
              pctLabel.textContent = `retrying (${attempt}/${maxRetries})‚Ä¶`;
              setTimeout(() => resolve(uploadOne(file, attempt + 1)), delay);
            } else { pctLabel.textContent = 'failed'; resolve({ file, ok: false, error: 'network error' }); }
          };

          xhr.onreadystatechange = function () {
            if (xhr.readyState === XMLHttpRequest.DONE) {
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  const data = JSON.parse(xhr.responseText);
                  bar.style.width = '100%';
                  pctLabel.textContent = '100%';
                  try {
                    const res = Array.isArray(data.results) ? data.results[0] : data;
                    if (res && typeof res === 'object') {
                      const docId = res.document_id || res.documentId;
                      const chunks = res.chunks || res.num_chunks;
                      const msg = [];
                      if (docId != null) msg.push(`doc ${docId}`);
                      if (chunks != null) msg.push(`${chunks} chunks`);
                      const row = item.querySelector('.progress-row span');
                      if (row && msg.length) row.textContent = `${row.textContent} ‚Äî processed (${msg.join(', ')})`;
                    }
                  } catch {}
                  resolve({ file, ok: true, data });
                } catch (e) {
                  if (attempt < maxRetries) {
                    const delay = backoff(attempt);
                    pctLabel.textContent = `retrying (${attempt}/${maxRetries})‚Ä¶`;
                    setTimeout(() => resolve(uploadOne(file, attempt + 1)), delay);
                  } else { pctLabel.textContent = 'failed'; resolve({ file, ok: false, error: 'parse error' }); }
                }
              } else if (xhr.status >= 500 && attempt < maxRetries) {
                const delay = backoff(attempt);
                pctLabel.textContent = `retrying (${attempt}/${maxRetries})‚Ä¶`;
                setTimeout(() => resolve(uploadOne(file, attempt + 1)), delay);
              } else {
                pctLabel.textContent = 'failed';
                resolve({ file, ok: false, error: xhr.responseText || `HTTP ${xhr.status}` });
              }
            }
          };

          const form = new FormData();
          form.append('files', file);
          if (state.spaceId) form.append('space_id', String(state.spaceId));
          xhr.send(form);
        });
      }

      const queue = [...allFiles];
      const inFlight = new Set();
      const results = [];

      async function pump() {
        while (inFlight.size < 4 && queue.length) {
          const f = queue.shift();
          const p = uploadOne(f).then((res) => {
            inFlight.delete(p);
            results.push(res);
            pump();
          });
          inFlight.add(p);
        }
        if (!queue.length && !inFlight.size) {
          loading.hidden = true;
          try {
            const items = results.map(r => {
              const name = r.file.webkitRelativePath || r.file.name;
              const icon = r.ok ? '‚úÖ' : '‚ùå';
              const err = r.error ? ` ‚Äî ${String(r.error)}` : '';
              return `<div>${icon} ${escapeHtml(name)}${err}</div>`;
            }).join('');
            status.innerHTML = items || 'Upload finished';
            showToast('Upload finished');
          } catch (e) {
            status.textContent = 'Upload finished';
          }
          droppedFiles = [];
          try { await loadKB(); } catch {}
        }
      }

      pump();
    });

    // Initialize
    function setupCollapsible(toggleId, contentId) {
      const t = document.getElementById(toggleId);
      const c = document.getElementById(contentId);
      if (!t || !c) return;
      const caret = t.querySelector('.caret');
      t.addEventListener('click', () => {
        const expanded = t.getAttribute('aria-expanded') === 'true';
        t.setAttribute('aria-expanded', String(!expanded));
        c.hidden = expanded;
        if (caret) caret.style.transform = expanded ? 'rotate(0deg)' : 'rotate(90deg)';
      });
    }

    window.addEventListener('DOMContentLoaded', async () => {
      const files = document.getElementById('files');
      const status = document.getElementById('uploadStatus');
      const badge = document.getElementById('fileSelectionText');
      if (searchInputEl) searchInputEl.value = '';
      if (files) files.value = '';
      if (status) status.textContent = '';
      if (dzStatus) dzStatus.textContent = 'Drop files here or use the file chooser below';
      if (badge) badge.textContent = 'No files selected.';
      droppedFiles = [];
      await initUser();
      await loadProviders();
      await loadSearchConfig();
      await loadUploadConfig();
      if (state && state.user) { try { await loadKB(); } catch (e) {} }
      setupCollapsible('kbToggle', 'kbContent');
      setupCollapsible('uploadToggle', 'uploadContent');
    });
  </script>
</body>
</html>